{
  "version": 3,
  "sources": ["../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils.tsx", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/types.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Visibility.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/aggregationTypes.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Grouping.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Ordering.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Pinning.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/ColumnSizing.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Headers.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/filterTypes.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Filters.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/sortTypes.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Sorting.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Expanding.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/Pagination.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/features/RowSelection.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/core.tsx", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/createTable.tsx", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils/columnFilterRowsFn.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils/globalFilterRowsFn.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils/sortRowsFn.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils/groupRowsFn.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils/expandRowsFn.ts", "../../.pnpm/@tanstack+table-core@8.0.0-alpha.10_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/table-core/src/utils/paginateRowsFn.ts", "../../.pnpm/@tanstack+react-table@8.0.0-alpha.11_react-dom@18.0.0+react@18.0.0/node_modules/@tanstack/react-table/src/index.tsx"],
  "sourcesContent": ["import React from 'react'\nimport {\n  Getter,\n  NoInfer,\n  PropGetterValue,\n  Renderable,\n  TableState,\n  Updater,\n} from './types'\n\nexport type IsAny<T> = 0 extends 1 & T ? true : false\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredKeys<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type Overwrite<T, U> = Omit<T, keyof U> & U\n\nexport type DataUpdateFunction<T> = (input: T) => T\n\nexport function functionalUpdate<T>(updater: Updater<T>, input: T): T {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<T>)(input)\n    : updater\n}\n\nexport function noop() {\n  //\n}\n\nexport function makeStateUpdater(key: keyof TableState, instance: unknown) {\n  return (updater: Updater<any>) => {\n    ;(instance as any).setState(<TTableState,>(old: TTableState) => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, (old as any)[key]),\n      }\n    })\n  }\n}\n\ntype AnyFunction = (...args: any) => any\n\nexport function isFunction<T extends AnyFunction>(d: any): d is T {\n  return d instanceof Function\n}\n\nexport function flattenBy<TNode>(\n  arr: TNode[],\n  getChildren: (item: TNode) => TNode[]\n) {\n  const flat: TNode[] = []\n\n  const recurse = (subArr: TNode[]) => {\n    subArr.forEach(item => {\n      flat.push(item)\n      const children = getChildren(item)\n      if (children?.length) {\n        recurse(children)\n      }\n    })\n  }\n\n  recurse(arr)\n\n  return flat\n}\n\ntype PropGetterImpl = <TBaseProps, TGetter extends Getter<TBaseProps>>(\n  initial: TBaseProps,\n  userProps?: TGetter\n) => PropGetterValue<TBaseProps, TGetter>\n\n// @ts-ignore // Just rely on the type, not the implementation\nexport const propGetter: PropGetterImpl = (initial, getter) => {\n  if (isFunction(getter)) {\n    return getter(initial)\n  }\n\n  return {\n    ...initial,\n    ...(getter ?? {}),\n  }\n}\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: string\n    debug?: () => any\n    onChange?: (result: TResult, previousResult?: TResult) => void\n  }\n): () => TResult {\n  let deps: any[] = []\n  let result: TResult | undefined\n\n  return () => {\n    let depTime: number\n    if (opts.key && opts.debug) depTime = performance.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (depsChanged) {\n      let oldResult = result\n      let resultTime: number\n      if (opts.key && opts.debug) resultTime = performance.now()\n      result = fn(...newDeps)\n      deps = newDeps\n      opts?.onChange?.(result, oldResult)\n\n      if (opts.key && opts.debug) {\n        if (opts?.debug()) {\n          const depEndTime =\n            Math.round((performance.now() - depTime!) * 100) / 100\n          const resultEndTime =\n            Math.round((performance.now() - resultTime!) * 100) / 100\n          const resultFpsPercentage = resultEndTime / 16\n\n          const pad = (str: number | string, num: number) => {\n            str = String(str)\n            while (str.length < num) {\n              str = ' ' + str\n            }\n            return str\n          }\n\n          console.info(\n            `%c\u23F1 ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n            `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120)\n            )}deg 100% 31%);`,\n            opts?.key,\n            {\n              length: `${deps.length} -> ${newDeps.length}`,\n              ...newDeps\n                .map((_, index) => {\n                  if (deps[index] !== newDeps[index]) {\n                    return [index, deps[index], newDeps[index]]\n                  }\n\n                  return false\n                })\n                .filter(Boolean)\n                .reduce(\n                  (accu, [a, b]: any) => ({\n                    ...accu,\n                    [a]: b,\n                  }),\n                  {}\n                ),\n              parent,\n            }\n          )\n        }\n      }\n\n      oldResult = undefined\n    }\n\n    return result!\n  }\n}\n\nexport type Render = typeof flexRender\n\nexport function flexRender<TProps extends {}>(\n  Comp: Renderable<TProps>,\n  props: TProps\n): React.ReactNode {\n  return !Comp ? null : isReactComponent(Comp) ? <Comp {...props} /> : Comp\n}\n\nfunction isReactComponent(component: unknown): component is React.FC {\n  return (\n    isClassComponent(component) ||\n    typeof component === 'function' ||\n    isExoticComponent(component)\n  )\n}\n\nfunction isClassComponent(component: any) {\n  return (\n    typeof component === 'function' &&\n    (() => {\n      const proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isExoticComponent(component: any) {\n  return (\n    typeof component === 'object' &&\n    typeof component.$$typeof === 'symbol' &&\n    ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description)\n  )\n}\n\n// export function hashString(str: string, seed = 0): string {\n//   let h1 = 0xdeadbeef ^ seed,\n//     h2 = 0x41c6ce57 ^ seed\n//   for (let i = 0, ch; i < str.length; i++) {\n//     ch = str.charCodeAt(i)\n//     h1 = Math.imul(h1 ^ ch, 2654435761)\n//     h2 = Math.imul(h2 ^ ch, 1597334677)\n//   }\n//   h1 =\n//     Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n//     Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n//   h2 =\n//     Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n//     Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n//   return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString()\n// }\n", "import React from 'react'\nimport {\n  CoreColumn,\n  CoreColumnDef,\n  CoreOptions,\n  CoreRow,\n  TableCore,\n} from './core'\nimport {\n  VisibilityInstance,\n  VisibilityTableState,\n  VisibilityColumn as ColumnVisibilityColumn,\n  VisibilityOptions,\n  VisibilityColumnDef,\n  VisibilityRow,\n} from './features/Visibility'\nimport {\n  ColumnOrderInstance,\n  ColumnOrderOptions,\n  ColumnOrderTableState,\n} from './features/Ordering'\nimport {\n  ColumnPinningColumn,\n  ColumnPinningColumnDef,\n  ColumnPinningInstance,\n  ColumnPinningOptions,\n  ColumnPinningTableState,\n} from './features/Pinning'\nimport { HeadersInstance, HeadersRow } from './features/Headers'\nimport {\n  FiltersColumn,\n  FiltersColumnDef,\n  FiltersInstance,\n  FiltersOptions,\n  FiltersTableState,\n} from './features/Filters'\nimport {\n  SortingColumn,\n  SortingColumnDef,\n  SortingInstance,\n  SortingOptions,\n  SortingTableState,\n} from './features/Sorting'\nimport {\n  GroupingColumn,\n  GroupingColumnDef,\n  GroupingInstance,\n  GroupingOptions,\n  GroupingRow,\n  GroupingTableState,\n} from './features/Grouping'\nimport {\n  ExpandedInstance,\n  ExpandedOptions,\n  ExpandedTableState,\n  ExpandedRow,\n} from './features/Expanding'\nimport { Overwrite } from './utils'\nimport {\n  ColumnSizingColumn,\n  ColumnSizingColumnDef,\n  ColumnSizingHeader,\n  ColumnSizingInstance,\n  ColumnSizingOptions,\n  ColumnSizingTableState,\n} from './features/ColumnSizing'\nimport {\n  PaginationInstance,\n  PaginationOptions,\n  PaginationTableState,\n} from './features/Pagination'\nimport {\n  RowSelectionInstance,\n  RowSelectionOptions,\n  RowSelectionRow,\n  RowSelectionTableState,\n} from './features/RowSelection'\n\n// declare global {\n//   const process.env.NODE_ENV !== 'production': boolean\n// }\n\nexport type DefaultGenerics = {\n  Row: unknown\n  Value: unknown\n  FilterFns: object\n  SortingFns: object\n  AggregationFns: object\n}\n\nexport type PartialGenerics = Partial<DefaultGenerics>\n\nexport type TableInstance<TGenerics extends PartialGenerics> =\n  TableCore<TGenerics> &\n    VisibilityInstance<TGenerics> &\n    ColumnOrderInstance<TGenerics> &\n    ColumnPinningInstance<TGenerics> &\n    HeadersInstance<TGenerics> &\n    FiltersInstance<TGenerics> &\n    SortingInstance<TGenerics> &\n    GroupingInstance<TGenerics> &\n    ColumnSizingInstance<TGenerics> &\n    ExpandedInstance<TGenerics> &\n    PaginationInstance<TGenerics> &\n    RowSelectionInstance<TGenerics>\n\nexport type Renderable<TProps> =\n  | React.ReactNode\n  | React.FunctionComponent<TProps>\n  | React.Component<TProps>\n\n//\n\nexport type Options<TGenerics extends PartialGenerics> =\n  CoreOptions<TGenerics> &\n    VisibilityOptions &\n    ColumnOrderOptions &\n    ColumnPinningOptions &\n    FiltersOptions<TGenerics> &\n    SortingOptions<TGenerics> &\n    GroupingOptions<TGenerics> &\n    ExpandedOptions<TGenerics> &\n    ColumnSizingOptions &\n    PaginationOptions<TGenerics> &\n    RowSelectionOptions<TGenerics>\n\nexport type Updater<T> = T | ((old: T) => T)\nexport type OnChangeFn<T> = (updaterOrValue: Updater<T>, value: T) => void\n\nexport type TableState = VisibilityTableState &\n  ColumnOrderTableState &\n  ColumnPinningTableState &\n  FiltersTableState &\n  SortingTableState &\n  ExpandedTableState &\n  GroupingTableState &\n  ColumnSizingTableState &\n  PaginationTableState &\n  RowSelectionTableState\n\nexport type Row<TGenerics extends PartialGenerics> = CoreRow<TGenerics> &\n  VisibilityRow<TGenerics> &\n  HeadersRow<TGenerics> &\n  GroupingRow &\n  RowSelectionRow &\n  ExpandedRow\n\nexport type RowValues = {\n  [key: string]: any\n}\n\nexport type RowModel<TGenerics extends PartialGenerics> = {\n  rows: Row<TGenerics>[]\n  flatRows: Row<TGenerics>[]\n  rowsById: Record<string, Row<TGenerics>>\n}\n\nexport type AccessorFn<TData> = (originalRow: TData, index: number) => any\n\nexport const Please_use_the_create_table_column_utilities_to_define_columns: unique symbol =\n  Symbol()\n\nexport type _NonGenerated<T> = Overwrite<\n  T,\n  {\n    [Please_use_the_create_table_column_utilities_to_define_columns]?: never\n  }\n>\n\nexport type ColumnDef<TGenerics extends PartialGenerics> =\n  CoreColumnDef<TGenerics> &\n    VisibilityColumnDef &\n    ColumnPinningColumnDef &\n    FiltersColumnDef<TGenerics> &\n    SortingColumnDef<TGenerics> &\n    GroupingColumnDef<TGenerics> &\n    ColumnSizingColumnDef\n\nexport type Column<TGenerics extends PartialGenerics> = ColumnDef<TGenerics> &\n  CoreColumn<TGenerics> &\n  ColumnVisibilityColumn &\n  ColumnPinningColumn &\n  FiltersColumn<TGenerics> &\n  SortingColumn<TGenerics> &\n  GroupingColumn<TGenerics> &\n  ColumnSizingColumn<TGenerics>\n\nexport type Cell<TGenerics extends PartialGenerics> = {\n  id: string\n  rowId: string\n  columnId: string\n  value: TGenerics['Value']\n  row: Row<TGenerics>\n  column: Column<TGenerics>\n  getCellProps: PropGetter<CellProps>\n  renderCell: () => React.ReactNode\n}\n\nexport type Header<TGenerics extends PartialGenerics> = CoreHeader<TGenerics> &\n  ColumnSizingHeader<TGenerics>\n\nexport type CoreHeader<TGenerics extends PartialGenerics> = {\n  id: string\n  depth: number\n  column: Column<TGenerics>\n  getWidth: () => number\n  subHeaders: Header<TGenerics>[]\n  colSpan?: number\n  rowSpan?: number\n  getHeaderProps: PropGetter<HeaderProps>\n  getFooterProps: PropGetter<HeaderProps>\n  getLeafHeaders: () => Header<TGenerics>[]\n  isPlaceholder?: boolean\n  placeholderId?: string\n  renderHeader: (options?: { renderPlaceholder?: boolean }) => React.ReactNode\n  renderFooter: (options?: { renderPlaceholder?: boolean }) => React.ReactNode\n}\n\nexport type HeaderGroup<TGenerics extends PartialGenerics> = {\n  id: string\n  depth: number\n  headers: Header<TGenerics>[]\n  getHeaderGroupProps: PropGetter<HeaderGroupProps>\n  getFooterGroupProps: PropGetter<FooterGroupProps>\n}\n\nexport type HeaderRenderProps<THeader> = {\n  header: THeader\n}\n\nexport type FooterRenderProps<THeader> = {\n  header: THeader\n}\n\nexport type CellRenderProps<TCell, TRow> = {\n  cell: TCell\n  row: TRow\n}\n\nexport type TableProps = {\n  role: string\n}\n\nexport type TableBodyProps = {\n  role: string\n}\n\nexport type TableHeadProps = {\n  key: string\n  role: string\n}\n\nexport type TableFooterProps = {\n  key: string\n  role: string\n}\n\nexport type HeaderGroupProps = {\n  key: string\n  role: string\n}\n\nexport type FooterGroupProps = {\n  key: string\n  role: string\n}\n\nexport type HeaderProps = {\n  key: string\n  role: string\n  colSpan?: number\n  rowSpan?: number\n}\n\nexport type FooterProps = {\n  key: string\n  role: string\n  colSpan?: number\n  rowSpan?: number\n}\n\nexport type RowProps = {\n  key: string\n  role: string\n}\n\nexport type CellProps = {\n  key: string\n  role: string\n}\n\n//\n\nexport type PropGetter<TBase> = <TGetter extends Getter<TBase>>(\n  userProps?: TGetter\n) => PropGetterValue<TBase, TGetter>\n\nexport type Getter<TInitial> =\n  | ((initial: TInitial) => object)\n  | object\n  | undefined\n\nexport type PropGetterValue<TBase, TGetter> = TGetter extends undefined\n  ? TBase\n  : TGetter extends (...args: any[]) => infer TReturn\n  ? Overwrite<TBase, TReturn>\n  : TGetter extends object\n  ? Overwrite<TBase, TGetter>\n  : never\n\nexport type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n", "import {\n  Cell,\n  Column,\n  Getter,\n  OnChangeFn,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type VisibilityOptions = {\n  onColumnVisibilityChange?: OnChangeFn<VisibilityState>\n  enableHiding?: boolean\n}\n\nexport type VisibilityDefaultOptions = {\n  onColumnVisibilityChange: OnChangeFn<VisibilityState>\n}\n\nexport type VisibilityState = Record<string, boolean>\n\nexport type VisibilityTableState = {\n  columnVisibility: VisibilityState\n}\n\nexport type VisibilityInstance<TGenerics extends PartialGenerics> = {\n  getVisibleFlatColumns: () => Column<TGenerics>[]\n  getVisibleLeafColumns: () => Column<TGenerics>[]\n  setColumnVisibility: (updater: Updater<VisibilityState>) => void\n  toggleColumnVisibility: (columnId: string, value?: boolean) => void\n  toggleAllColumnsVisible: (value?: boolean) => void\n  getColumnIsVisible: (columId: string) => boolean\n  getColumnCanHide: (columnId: string) => boolean\n  getIsAllColumnsVisible: () => boolean\n  getIsSomeColumnsVisible: () => boolean\n  getToggleAllColumnsVisibilityProps: <\n    TGetter extends Getter<ToggleAllColumnsVisibilityProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleAllColumnsVisibilityProps, TGetter>\n}\n\ntype ToggleVisibilityProps = {}\ntype ToggleAllColumnsVisibilityProps = {}\n\nexport type VisibilityColumnDef = {\n  enableHiding?: boolean\n  defaultCanHide?: boolean\n}\n\nexport type VisibilityRow<TGenerics extends PartialGenerics> = {\n  getVisibleCells: () => Cell<TGenerics>[]\n}\n\nexport type VisibilityColumn = {\n  getCanHide: () => boolean\n  getIsVisible: () => boolean\n  toggleVisibility: (value?: boolean) => void\n  getToggleVisibilityProps: <TGetter extends Getter<ToggleVisibilityProps>>(\n    userProps?: TGetter\n  ) => PropGetterValue<ToggleVisibilityProps, TGetter>\n}\n\n//\n\nexport const Visibility = {\n  getInitialState: (): VisibilityTableState => {\n    return {\n      columnVisibility: {},\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): VisibilityDefaultOptions => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance),\n    }\n  },\n\n  getDefaultColumn: () => {\n    return {\n      defaultIsVisible: true,\n    }\n  },\n\n  createColumn: <TGenerics extends PartialGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): VisibilityColumn => {\n    return {\n      getCanHide: () => instance.getColumnCanHide(column.id),\n      getIsVisible: () => instance.getColumnIsVisible(column.id),\n      toggleVisibility: value =>\n        instance.toggleColumnVisibility(column.id, value),\n      getToggleVisibilityProps: userProps => {\n        const props: ToggleVisibilityProps = {\n          type: 'checkbox',\n          checked: column.getIsVisible?.(),\n          title: 'Toggle Column Visibility',\n          onChange: (e: MouseEvent | TouchEvent) => {\n            column.toggleVisibility?.((e.target as HTMLInputElement).checked)\n          },\n        }\n\n        return propGetter(props, userProps)\n      },\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): VisibilityInstance<TGenerics> => {\n    return {\n      getVisibleFlatColumns: memo(\n        () => [\n          instance.getAllFlatColumns(),\n          instance\n            .getAllFlatColumns()\n            .filter(d => d.getIsVisible?.())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        allFlatColumns => {\n          return allFlatColumns.filter(d => d.getIsVisible?.())\n        },\n        {\n          key: 'getVisibleFlatColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getVisibleLeafColumns: memo(\n        () => [\n          instance.getAllLeafColumns(),\n          instance\n            .getAllLeafColumns()\n            .filter(d => d.getIsVisible?.())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        allFlatColumns => {\n          return allFlatColumns.filter(d => d.getIsVisible?.())\n        },\n        {\n          key: 'getVisibleLeafColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      setColumnVisibility: updater =>\n        instance.options.onColumnVisibilityChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnVisibility)\n        ),\n\n      toggleColumnVisibility: (columnId, value) => {\n        if (!columnId) return\n\n        if (instance.getColumnCanHide(columnId)) {\n          instance.setColumnVisibility(old => ({\n            ...old,\n            [columnId]: value ?? !instance.getColumnIsVisible(columnId),\n          }))\n        }\n      },\n\n      toggleAllColumnsVisible: value => {\n        value = value ?? !instance.getIsAllColumnsVisible()\n\n        instance.setColumnVisibility(\n          instance.getAllLeafColumns().reduce(\n            (obj, column) => ({\n              ...obj,\n              [column.id]: !value ? !column.getCanHide?.() : value,\n            }),\n            {}\n          )\n        )\n      },\n\n      getColumnIsVisible: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          instance.getState().columnVisibility?.[columnId] ??\n          column.defaultIsVisible ??\n          true\n        )\n      },\n\n      getColumnCanHide: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          instance.options.enableHiding ??\n          column.enableHiding ??\n          column.defaultCanHide ??\n          true\n        )\n      },\n\n      getIsAllColumnsVisible: () =>\n        !instance.getAllLeafColumns().some(column => !column.getIsVisible?.()),\n\n      getIsSomeColumnsVisible: () =>\n        instance.getAllLeafColumns().some(column => column.getIsVisible?.()),\n\n      getToggleAllColumnsVisibilityProps: userProps => {\n        const props: ToggleAllColumnsVisibilityProps = {\n          onChange: (e: MouseEvent) => {\n            instance.toggleAllColumnsVisible(\n              (e.target as HTMLInputElement)?.checked\n            )\n          },\n          type: 'checkbox',\n          title: 'Toggle visibility for all columns',\n          checked: instance.getIsAllColumnsVisible(),\n          indeterminate:\n            !instance.getIsAllColumnsVisible() &&\n            instance.getIsSomeColumnsVisible()\n              ? 'indeterminate'\n              : undefined,\n        }\n\n        return propGetter(props, userProps)\n      },\n    }\n  },\n}\n", "export const aggregationTypes = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count,\n}\n\nexport type BuiltInAggregationType = keyof typeof aggregationTypes\n\nfunction sum(_leafValues: unknown[], childValues: unknown[]) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childValues.reduce(\n    (sum: number, next: unknown) => sum + (typeof next === 'number' ? next : 0),\n    0\n  )\n}\n\nfunction min(_leafValues: unknown[], childValues: unknown[]) {\n  let min: number | undefined\n\n  for (const value of childValues as number[]) {\n    if (\n      value != null &&\n      (min! > value || (min === undefined && value >= value))\n    ) {\n      min = value\n    }\n  }\n\n  return min\n}\n\nfunction max(_leafValues: unknown[], childValues: unknown[]) {\n  let max: number | undefined\n\n  for (const value of childValues as number[]) {\n    if (\n      value != null &&\n      (max! < value || (max === undefined && value >= value))\n    ) {\n      max = value\n    }\n  }\n\n  return max\n}\n\nfunction extent(_leafValues: unknown[], childValues: unknown[]) {\n  let min: number | undefined\n  let max: number | undefined\n\n  for (const value of childValues as number[]) {\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value\n      } else {\n        if (min > value) min = value\n        if (max! < value) max = value\n      }\n    }\n  }\n\n  return [min, max]\n}\n\nfunction mean(leafValues: unknown[]) {\n  let count = 0\n  let sum = 0\n\n  for (let value of leafValues as number[]) {\n    if (value != null && (value = +value) >= value) {\n      ++count, (sum += value)\n    }\n  }\n\n  if (count) return sum / count\n\n  return\n}\n\nfunction median(values: unknown[]) {\n  if (!values.length) {\n    return\n  }\n\n  let min = 0\n  let max = 0\n\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value)\n      max = Math.max(max, value)\n    }\n  })\n\n  return (min + max) / 2\n}\n\nfunction unique<T>(values: T[]) {\n  return Array.from(new Set(values).values())\n}\n\nfunction uniqueCount(values: unknown[]) {\n  return new Set(values).size\n}\n\nfunction count(values: unknown[]) {\n  return values.length\n}\n", "import React, { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport { BuiltInAggregationType, aggregationTypes } from '../aggregationTypes'\nimport {\n  Cell,\n  Column,\n  Getter,\n  OnChangeFn,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  Updater,\n  PartialGenerics,\n} from '../types'\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n  propGetter,\n} from '../utils'\n\nexport type GroupingState = string[]\n\nexport type AggregationFn<TGenerics extends PartialGenerics> = (\n  leafValues: TGenerics['Row'][],\n  childValues: TGenerics['Row'][]\n) => any\n\nexport type CustomAggregationTypes<TGenerics extends PartialGenerics> = Record<\n  string,\n  AggregationFn<TGenerics>\n>\n\nexport type AggregationType<TGenerics extends PartialGenerics> =\n  | 'auto'\n  | BuiltInAggregationType\n  | keyof TGenerics['AggregationFns']\n  | AggregationFn<TGenerics>\n\nexport type GroupingTableState = {\n  grouping: GroupingState\n}\n\nexport type GroupingColumnDef<TGenerics extends PartialGenerics> = {\n  aggregationType?: AggregationType<Overwrite<TGenerics, { Value: any }>>\n  aggregateValue?: (columnValue: unknown) => any\n  renderAggregatedCell?: () => React.ReactNode\n  enableGrouping?: boolean\n  defaultCanGroup?: boolean\n}\n\nexport type GroupingColumn<TGenerics extends PartialGenerics> = {\n  aggregationType?: AggregationType<Overwrite<TGenerics, { Value: any }>>\n  getCanGroup: () => boolean\n  getIsGrouped: () => boolean\n  getGroupedIndex: () => number\n  toggleGrouping: () => void\n  getToggleGroupingProps: <TGetter extends Getter<ToggleGroupingProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleGroupingProps, TGetter>\n}\n\nexport type GroupingRow = {\n  groupingColumnId?: string\n  groupingValue?: any\n  getIsGrouped: () => boolean\n}\n\nexport type GroupingCell = {\n  getIsGrouped: () => boolean\n  getIsPlaceholder: () => boolean\n  getIsAggregated: () => boolean\n}\n\nexport type ColumnDefaultOptions = {\n  // Column\n  onGroupingChange: OnChangeFn<GroupingState>\n  autoResetGrouping: boolean\n  enableGrouping: boolean\n}\n\nexport type GroupingOptions<TGenerics extends PartialGenerics> = {\n  aggregationTypes?: TGenerics['AggregationFns']\n  onGroupingChange?: OnChangeFn<GroupingState>\n  autoResetGrouping?: boolean\n  enableGrouping?: boolean\n  enableGroupingRemoval?: boolean\n  groupRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n\n  groupedColumnMode?: false | 'reorder' | 'remove'\n}\n\nexport type GroupingColumnMode = false | 'reorder' | 'remove'\n\nexport type ToggleGroupingProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type GroupingInstance<TGenerics extends PartialGenerics> = {\n  _notifyGroupingReset: () => void\n  getColumnAutoAggregationFn: (\n    columnId: string\n  ) => AggregationFn<TGenerics> | undefined\n  getColumnAggregationFn: (\n    columnId: string\n  ) => AggregationFn<TGenerics> | undefined\n  setGrouping: (updater: Updater<GroupingState>) => void\n  resetGrouping: () => void\n  toggleColumnGrouping: (columnId: string) => void\n  getColumnCanGroup: (columnId: string) => boolean\n  getColumnIsGrouped: (columnId: string) => boolean\n  getColumnGroupedIndex: (columnId: string) => number\n  getToggleGroupingProps: <TGetter extends Getter<ToggleGroupingProps>>(\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleGroupingProps, TGetter>\n  getRowIsGrouped: (rowId: string) => boolean\n  getPreGroupedRowModel: () => RowModel<TGenerics>\n  getGroupedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Grouping = {\n  getDefaultColumn: <\n    TGenerics extends PartialGenerics\n  >(): GroupingColumnDef<TGenerics> => {\n    return {\n      aggregationType: 'auto',\n    }\n  },\n\n  getInitialState: (): GroupingTableState => {\n    return {\n      grouping: [],\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): GroupingOptions<TGenerics> => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', instance),\n      autoResetGrouping: true,\n      groupedColumnMode: 'reorder',\n    }\n  },\n\n  createColumn: <TGenerics extends PartialGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingColumn<TGenerics> => {\n    return {\n      aggregationType: column.aggregationType,\n      getCanGroup: () => instance.getColumnCanGroup(column.id),\n      getGroupedIndex: () => instance.getColumnGroupedIndex(column.id),\n      getIsGrouped: () => instance.getColumnIsGrouped(column.id),\n      toggleGrouping: () => instance.toggleColumnGrouping(column.id),\n      getToggleGroupingProps: userProps =>\n        instance.getToggleGroupingProps(column.id, userProps),\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): GroupingInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifyGroupingReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetGrouping\n        ) {\n          instance.resetGrouping()\n        }\n      },\n      getColumnAutoAggregationFn: columnId => {\n        const firstRow = instance.getCoreRowModel().flatRows[0]\n\n        const value = firstRow?.values[columnId]\n\n        if (typeof value === 'number') {\n          return aggregationTypes.sum\n        }\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return aggregationTypes.extent\n        }\n\n        return aggregationTypes.count\n      },\n      getColumnAggregationFn: columnId => {\n        const column = instance.getColumn(columnId)\n        const userAggregationTypes = instance.options.aggregationTypes\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.aggregationType)\n          ? column.aggregationType\n          : column.aggregationType === 'auto'\n          ? instance.getColumnAutoFilterFn(columnId)\n          : (userAggregationTypes as Record<string, any>)?.[\n              column.aggregationType as string\n            ] ??\n            (aggregationTypes[\n              column.aggregationType as BuiltInAggregationType\n            ] as AggregationFn<TGenerics>)\n      },\n\n      setGrouping: updater =>\n        instance.options.onGroupingChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().grouping)\n        ),\n\n      toggleColumnGrouping: columnId => {\n        instance.setGrouping(old => {\n          // Find any existing grouping for this column\n          if (old?.includes(columnId)) {\n            return old.filter(d => d !== columnId)\n          }\n\n          return [...(old ?? []), columnId]\n        })\n      },\n\n      getColumnCanGroup: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableGrouping ??\n          instance.options.enableGrouping ??\n          column.defaultCanGroup ??\n          !!column.accessorFn\n        )\n      },\n\n      getColumnIsGrouped: columnId => {\n        return instance.getState().grouping?.includes(columnId)\n      },\n\n      getColumnGroupedIndex: columnId =>\n        instance.getState().grouping?.indexOf(columnId),\n\n      resetGrouping: () => {\n        instance.setGrouping(instance.initialState?.grouping ?? [])\n      },\n\n      getToggleGroupingProps: (columnId, userProps) => {\n        const column = instance.getColumn(columnId)\n\n        const canGroup = column.getCanGroup()\n\n        const initialProps: ToggleGroupingProps = {\n          title: canGroup ? 'Toggle Grouping' : undefined,\n          onClick: canGroup\n            ? (e: MouseEvent | TouchEvent) => {\n                e.persist()\n                column.toggleGrouping?.()\n              }\n            : undefined,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getRowIsGrouped: rowId => !!instance.getRow(rowId)?.groupingColumnId,\n\n      getPreGroupedRowModel: () => instance.getSortedRowModel(),\n      getGroupedRowModel: memo(\n        () => [\n          instance.getState().grouping,\n          instance.getSortedRowModel(),\n          instance.options.groupRowsFn,\n        ],\n        (grouping, rowModel, groupRowsFn) => {\n          if (!groupRowsFn || !grouping.length) {\n            return rowModel\n          }\n\n          return groupRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getGroupedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n    }\n  },\n\n  createRow: <TGenerics extends PartialGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingRow => {\n    return {\n      getIsGrouped: () => instance.getRowIsGrouped(row.id),\n    }\n  },\n\n  createCell: <TGenerics extends PartialGenerics>(\n    cell: Cell<TGenerics> & GroupingCell,\n    column: Column<TGenerics>,\n    row: Row<TGenerics>,\n    _instance: TableInstance<TGenerics>\n  ): GroupingCell => {\n    return {\n      getIsGrouped: () =>\n        column.getIsGrouped() && column.id === row.groupingColumnId,\n      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n      getIsAggregated: () =>\n        !cell.getIsGrouped() &&\n        !cell.getIsPlaceholder() &&\n        row.subRows?.length > 1,\n    }\n  },\n\n  orderColumns: <TGenerics extends PartialGenerics>(\n    leafColumns: Column<TGenerics>[],\n    grouping: string[],\n    groupedColumnMode?: GroupingColumnMode\n  ) => {\n    if (!grouping?.length || !groupedColumnMode) {\n      return leafColumns\n    }\n\n    const nonGroupingColumns = leafColumns.filter(\n      col => !grouping.includes(col.id)\n    )\n\n    if (groupedColumnMode === 'remove') {\n      return nonGroupingColumns\n    }\n\n    const groupingColumns = grouping\n      .map(g => leafColumns.find(col => col.id === g)!)\n      .filter(Boolean)\n\n    return [...groupingColumns, ...nonGroupingColumns]\n  },\n}\n", "import { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nimport {\n  TableInstance,\n  OnChangeFn,\n  Updater,\n  Column,\n  PartialGenerics,\n} from '../types'\n\nimport { Grouping } from './Grouping'\n\nexport type ColumnOrderState = string[]\n\nexport type ColumnOrderTableState = {\n  columnOrder: ColumnOrderState\n}\n\nexport type ColumnOrderOptions = {\n  onColumnOrderChange?: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderDefaultOptions = {\n  onColumnOrderChange: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderInstance<TGenerics extends PartialGenerics> = {\n  setColumnOrder: (updater: Updater<ColumnOrderState>) => void\n  resetColumnOrder: () => void\n  getOrderColumnsFn: () => (columns: Column<TGenerics>[]) => Column<TGenerics>[]\n}\n\n//\n\nexport const Ordering = {\n  getInitialState: (): ColumnOrderTableState => {\n    return {\n      columnOrder: [],\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnOrderDefaultOptions => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', instance),\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnOrderInstance<TGenerics> => {\n    return {\n      setColumnOrder: updater =>\n        instance.options.onColumnOrderChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnOrder)\n        ),\n      resetColumnOrder: () => {\n        instance.setColumnOrder(instance.initialState.columnOrder ?? [])\n      },\n      getOrderColumnsFn: memo(\n        () => [\n          instance.getState().columnOrder,\n          instance.getState().grouping,\n          instance.options.groupedColumnMode,\n        ],\n        (columnOrder, grouping, groupedColumnMode) => columns => {\n          // Sort grouped columns to the start of the column list\n          // before the headers are built\n          let orderedColumns: Column<TGenerics>[] = []\n\n          // If there is no order, return the normal columns\n          if (!columnOrder?.length) {\n            orderedColumns = columns\n          } else {\n            const columnOrderCopy = [...columnOrder]\n\n            // If there is an order, make a copy of the columns\n            const columnsCopy = [...columns]\n\n            // And make a new ordered array of the columns\n\n            // Loop over the columns and place them in order into the new array\n            while (columnsCopy.length && columnOrderCopy.length) {\n              const targetColumnId = columnOrderCopy.shift()\n              const foundIndex = columnsCopy.findIndex(\n                d => d.id === targetColumnId\n              )\n              if (foundIndex > -1) {\n                orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]!)\n              }\n            }\n\n            // If there are any columns left, add them to the end\n            orderedColumns = [...orderedColumns, ...columnsCopy]\n          }\n\n          return Grouping.orderColumns(\n            orderedColumns,\n            grouping,\n            groupedColumnMode\n          )\n        },\n        {\n          key: 'getOrderColumnsFn',\n          // debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n    }\n  },\n}\n", "import {\n  OnChangeFn,\n  Updater,\n  TableInstance,\n  Column,\n  PartialGenerics,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater } from '../utils'\n\ntype ColumnPinningPosition = false | 'left' | 'right'\n\nexport type ColumnPinningState = {\n  left?: string[]\n  right?: string[]\n}\n\nexport type ColumnPinningTableState = {\n  columnPinning: ColumnPinningState\n}\n\nexport type ColumnPinningOptions = {\n  onColumnPinningChange?: OnChangeFn<ColumnPinningState>\n  enablePinning?: boolean\n}\n\nexport type ColumnPinningDefaultOptions = {\n  onColumnPinningChange: OnChangeFn<ColumnPinningState>\n}\n\nexport type ColumnPinningColumnDef = {\n  enablePinning?: boolean\n  defaultCanPin?: boolean\n}\n\nexport type ColumnPinningColumn = {\n  getCanPin: () => boolean\n  getPinnedIndex: () => number\n  getIsPinned: () => ColumnPinningPosition\n  pin: (position: ColumnPinningPosition) => void\n}\n\nexport type ColumnPinningInstance<TGenerics extends PartialGenerics> = {\n  setColumnPinning: (updater: Updater<ColumnPinningState>) => void\n  resetColumnPinning: () => void\n  pinColumn: (columnId: string, position: ColumnPinningPosition) => void\n  getColumnCanPin: (columnId: string) => boolean\n  getColumnIsPinned: (columnId: string) => ColumnPinningPosition\n  getColumnPinnedIndex: (columnId: string) => number\n}\n\n//\n\nexport const Pinning = {\n  getInitialState: (): ColumnPinningTableState => {\n    return {\n      columnPinning: {\n        left: [],\n        right: [],\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningDefaultOptions => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', instance),\n    }\n  },\n\n  createColumn: <TGenerics extends PartialGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningColumn => {\n    return {\n      getCanPin: () => instance.getColumnCanPin(column.id),\n      getPinnedIndex: () => instance.getColumnPinnedIndex(column.id),\n      getIsPinned: () => instance.getColumnIsPinned(column.id),\n      pin: position => instance.pinColumn(column.id, position),\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningInstance<TGenerics> => {\n    return {\n      setColumnPinning: updater =>\n        instance.options.onColumnPinningChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnPinning)\n        ),\n\n      resetColumnPinning: () =>\n        instance.setColumnPinning(instance.initialState?.columnPinning ?? {}),\n\n      pinColumn: (columnId, position) => {\n        const column = instance.getColumn(columnId)\n\n        const columnIds = column\n          ?.getLeafColumns()\n          .map(d => d.id)\n          .filter(Boolean) as string[]\n\n        instance.setColumnPinning(old => {\n          if (position === 'right') {\n            return {\n              left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n              right: [\n                ...(old?.right ?? []).filter(d => !columnIds?.includes(d)),\n                ...columnIds,\n              ],\n            }\n          }\n\n          if (position === 'left') {\n            return {\n              left: [\n                ...(old?.left ?? []).filter(d => !columnIds?.includes(d)),\n                ...columnIds,\n              ],\n              right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n            }\n          }\n\n          return {\n            left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n            right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n          }\n        })\n      },\n\n      getColumnCanPin: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const leafColumns = column.getLeafColumns()\n\n        return leafColumns.some(\n          d =>\n            d.enablePinning ??\n            instance.options.enablePinning ??\n            d.defaultCanPin ??\n            !!d.accessorFn\n        )\n      },\n\n      getColumnIsPinned: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const leafColumnIds = column.getLeafColumns().map(d => d.id)\n\n        const { left, right } = instance.getState().columnPinning\n\n        const isLeft = leafColumnIds.some(d => left?.includes(d))\n        const isRight = leafColumnIds.some(d => right?.includes(d))\n\n        return isLeft ? 'left' : isRight ? 'right' : false\n      },\n\n      getColumnPinnedIndex: columnId => {\n        const position = instance.getColumnIsPinned(columnId)\n\n        return position\n          ? instance.getState().columnPinning?.[position]?.indexOf(columnId) ??\n              -1\n          : 0\n      },\n    }\n  },\n}\n", "import {\n  MouseEvent as ReactMouseEvent,\n  TouchEvent as ReactTouchEvent,\n} from 'react'\nimport {\n  Column,\n  Getter,\n  Header,\n  OnChangeFn,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\n//\n\nexport type ColumnSizing = Record<string, number>\n\nexport type ColumnSizingInfoState = {\n  startOffset: null | number\n  startSize: null | number\n  deltaOffset: null | number\n  deltaPercentage: null | number\n  isResizingColumn: false | string\n  columnSizingStart: [string, number][]\n}\n\nexport type ColumnSizingTableState = {\n  columnSizing: ColumnSizing\n  columnSizingInfo: ColumnSizingInfoState\n}\n\nexport type ColumnResizeMode = 'onChange' | 'onEnd'\n\nexport type ColumnSizingOptions = {\n  enableColumnResizing?: boolean\n  columnResizeMode?: ColumnResizeMode\n  onColumnSizingChange?: OnChangeFn<ColumnSizing>\n  onColumnSizingInfoChange?: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnSizingDefaultOptions = {\n  columnResizeMode: ColumnResizeMode\n  onColumnSizingChange: OnChangeFn<ColumnSizing>\n  onColumnSizingInfoChange: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnResizerProps = {\n  title?: string\n  onMouseDown?: (e: ReactMouseEvent) => void\n  onTouchStart?: (e: ReactTouchEvent) => void\n  draggable?: boolean\n  role?: string\n}\n\nexport type ColumnSizingInstance<TGenerics extends PartialGenerics> = {\n  setColumnSizing: (updater: Updater<ColumnSizing>) => void\n  setColumnSizingInfo: (updater: Updater<ColumnSizingInfoState>) => void\n  resetColumnSizing: () => void\n  resetColumnSize: (columnId: string) => void\n  resetHeaderSize: (headerId: string) => void\n  resetHeaderSizeInfo: () => void\n  getColumnCanResize: (columnId: string) => boolean\n  getHeaderCanResize: (headerId: string) => boolean\n  getHeaderResizerProps: <TGetter extends Getter<ColumnResizerProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ColumnResizerProps, TGetter>\n  getColumnIsResizing: (columnId: string) => boolean\n  getHeaderIsResizing: (headerId: string) => boolean\n}\n\nexport type ColumnSizingColumnDef = {\n  enableResizing?: boolean\n  defaultCanResize?: boolean\n}\n\nexport type ColumnSizingColumn<TGenerics extends PartialGenerics> = {\n  getCanResize: () => boolean\n  getIsResizing: () => boolean\n  resetSize: () => void\n}\n\nexport type ColumnSizingHeader<TGenerics extends PartialGenerics> = {\n  getCanResize: () => boolean\n  getIsResizing: () => boolean\n  getResizerProps: <TGetter extends Getter<ColumnResizerProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ColumnResizerProps, TGetter>\n  resetSize: () => void\n}\n\n//\n\nexport const defaultColumnSizing = {\n  width: 150,\n  minWidth: 20,\n  maxWidth: Number.MAX_SAFE_INTEGER,\n}\n\nexport const ColumnSizing = {\n  getInitialState: (): ColumnSizingTableState => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: {\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: [],\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingDefaultOptions => {\n    return {\n      columnResizeMode: 'onEnd',\n      onColumnSizingChange: makeStateUpdater('columnSizing', instance),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', instance),\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingInstance<TGenerics> => {\n    return {\n      setColumnSizing: updater =>\n        instance.options.onColumnSizingChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnSizing)\n        ),\n      setColumnSizingInfo: updater =>\n        instance.options.onColumnSizingInfoChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().columnSizingInfo)\n        ),\n      resetColumnSizing: () => {\n        instance.setColumnSizing(instance.initialState.columnSizing ?? {})\n      },\n      resetHeaderSizeInfo: () => {\n        instance.setColumnSizingInfo(\n          instance.initialState.columnSizingInfo ?? {}\n        )\n      },\n      resetColumnSize: columnId => {\n        instance.setColumnSizing(({ [columnId]: _, ...rest }) => {\n          return rest\n        })\n      },\n      resetHeaderSize: headerId => {\n        const header = instance.getHeader(headerId)\n\n        return instance.resetColumnSize(header.column.id)\n      },\n      getHeaderCanResize: headerId => {\n        const header = instance.getHeader(headerId)\n\n        if (!header) {\n          throw new Error()\n        }\n\n        return instance.getColumnCanResize(header.column.id)\n      },\n      getColumnCanResize: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableResizing ??\n          instance.options.enableColumnResizing ??\n          column.defaultCanResize ??\n          true\n        )\n      },\n      getColumnIsResizing: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          instance.getState().columnSizingInfo.isResizingColumn === columnId\n        )\n      },\n      getHeaderIsResizing: headerId => {\n        const header = instance.getHeader(headerId)\n\n        if (!header) {\n          throw new Error()\n        }\n\n        return instance.getColumnIsResizing(header.column.id)\n      },\n\n      getHeaderResizerProps: (headerId, userProps) => {\n        const header = instance.getHeader(headerId)\n        const column = instance.getColumn(header.column.id)\n\n        const canResize = column.getCanResize()\n\n        const onResizeStart = (e: ReactMouseEvent | ReactTouchEvent) => {\n          if (isTouchStartEvent(e)) {\n            // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n            if (e.touches && e.touches.length > 1) {\n              return\n            }\n          }\n\n          const header = headerId ? instance.getHeader(headerId) : undefined\n\n          const startSize = header ? header.getWidth() : column.getWidth()\n\n          const columnSizingStart: [string, number][] = header\n            ? header.getLeafHeaders().map(d => [d.column.id, d.getWidth()])\n            : [[column.id, column.getWidth()]]\n\n          const clientX = isTouchStartEvent(e)\n            ? Math.round(e.touches[0].clientX)\n            : e.clientX\n\n          const updateOffset = (\n            eventType: 'move' | 'end',\n            clientXPos?: number\n          ) => {\n            if (typeof clientXPos !== 'number') {\n              return\n            }\n\n            let newColumnSizing: ColumnSizing = {}\n\n            instance.setColumnSizingInfo(old => {\n              const deltaOffset = clientXPos - (old?.startOffset ?? 0)\n              const deltaPercentage = Math.max(\n                deltaOffset / (old?.startSize ?? 0),\n                -0.999999\n              )\n\n              old.columnSizingStart.forEach(([columnId, headerWidth]) => {\n                newColumnSizing[columnId] =\n                  Math.round(\n                    Math.max(headerWidth + headerWidth * deltaPercentage, 0) *\n                      100\n                  ) / 100\n              })\n\n              return {\n                ...old,\n                deltaOffset,\n                deltaPercentage,\n              }\n            })\n\n            if (\n              instance.options.columnResizeMode === 'onChange' ||\n              eventType === 'end'\n            ) {\n              instance.setColumnSizing(old => ({\n                ...old,\n                ...newColumnSizing,\n              }))\n            }\n          }\n\n          const onMove = (clientXPos?: number) =>\n            updateOffset('move', clientXPos)\n\n          const onEnd = (clientXPos?: number) => {\n            updateOffset('end', clientXPos)\n\n            instance.setColumnSizingInfo(old => ({\n              ...old,\n              isResizingColumn: false,\n              startOffset: null,\n              startSize: null,\n              deltaOffset: null,\n              deltaPercentage: null,\n              columnSizingStart: [],\n            }))\n          }\n\n          const mouseEvents = {\n            moveHandler: (e: MouseEvent) => onMove(e.clientX),\n            upHandler: (e: MouseEvent) => {\n              document.removeEventListener('mousemove', mouseEvents.moveHandler)\n              document.removeEventListener('mouseup', mouseEvents.upHandler)\n              onEnd(e.clientX)\n            },\n          }\n\n          const touchEvents = {\n            moveHandler: (e: TouchEvent) => {\n              if (e.cancelable) {\n                e.preventDefault()\n                e.stopPropagation()\n              }\n              onMove(e.touches[0].clientX)\n              return false\n            },\n            upHandler: (e: TouchEvent) => {\n              document.removeEventListener('touchmove', touchEvents.moveHandler)\n              document.removeEventListener('touchend', touchEvents.upHandler)\n              if (e.cancelable) {\n                e.preventDefault()\n                e.stopPropagation()\n              }\n              onEnd(e.touches[0].clientX)\n            },\n          }\n\n          const passiveIfSupported = passiveEventSupported()\n            ? { passive: false }\n            : false\n\n          if (isTouchStartEvent(e)) {\n            document.addEventListener(\n              'touchmove',\n              touchEvents.moveHandler,\n              passiveIfSupported\n            )\n            document.addEventListener(\n              'touchend',\n              touchEvents.upHandler,\n              passiveIfSupported\n            )\n          } else {\n            document.addEventListener(\n              'mousemove',\n              mouseEvents.moveHandler,\n              passiveIfSupported\n            )\n            document.addEventListener(\n              'mouseup',\n              mouseEvents.upHandler,\n              passiveIfSupported\n            )\n          }\n\n          instance.setColumnSizingInfo(old => ({\n            ...old,\n            startOffset: clientX,\n            startSize,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart,\n            isResizingColumn: column.id,\n          }))\n        }\n\n        const initialProps: ColumnResizerProps = canResize\n          ? {\n              title: 'Toggle Grouping',\n              draggable: false,\n              role: 'separator',\n              onMouseDown: (e: ReactMouseEvent) => {\n                e.persist()\n                onResizeStart(e)\n              },\n              onTouchStart: (e: ReactTouchEvent) => {\n                e.persist()\n                onResizeStart(e)\n              },\n            }\n          : {}\n\n        return propGetter(initialProps, userProps)\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends PartialGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingColumn<TGenerics> => {\n    return {\n      getIsResizing: () => instance.getColumnIsResizing(column.id),\n      getCanResize: () => instance.getColumnCanResize(column.id),\n      resetSize: () => instance.resetColumnSize(column.id),\n    }\n  },\n\n  createHeader: <TGenerics extends PartialGenerics>(\n    header: Header<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingHeader<TGenerics> => {\n    return {\n      getIsResizing: () => instance.getColumnIsResizing(header.column.id),\n      getCanResize: () => instance.getColumnCanResize(header.column.id),\n      resetSize: () => instance.resetColumnSize(header.column.id),\n      getResizerProps: userProps =>\n        instance.getHeaderResizerProps(header.id, userProps),\n    }\n  },\n}\n\nlet passiveSupported: boolean | null = null\nexport function passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported\n\n  let supported = false\n  try {\n    const options = {\n      get passive() {\n        supported = true\n        return false\n      },\n    }\n\n    const noop = () => {}\n\n    window.addEventListener('test', noop, options)\n    window.removeEventListener('test', noop)\n  } catch (err) {\n    supported = false\n  }\n  passiveSupported = supported\n  return passiveSupported\n}\n\nfunction isTouchStartEvent(\n  e: ReactTouchEvent | ReactMouseEvent\n): e is ReactTouchEvent {\n  return e.type === 'touchstart'\n}\n", "import {\n  Cell,\n  Column,\n  CoreHeader,\n  FooterGroupProps,\n  FooterProps,\n  Getter,\n  Header,\n  HeaderGroup,\n  HeaderGroupProps,\n  HeaderProps,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n} from '../types'\nimport { propGetter, memo, flexRender } from '../utils'\nimport { ColumnSizing } from './ColumnSizing'\n\nexport type HeadersRow<TGenerics extends PartialGenerics> = {\n  _getAllVisibleCells: () => Cell<TGenerics>[]\n  getVisibleCells: () => Cell<TGenerics>[]\n  getLeftVisibleCells: () => Cell<TGenerics>[]\n  getCenterVisibleCells: () => Cell<TGenerics>[]\n  getRightVisibleCells: () => Cell<TGenerics>[]\n}\n\nexport type HeadersInstance<TGenerics extends PartialGenerics> = {\n  createHeader: (\n    column: Column<TGenerics>,\n    options: {\n      id?: string\n      isPlaceholder?: boolean\n      placeholderId?: string\n      depth: number\n    }\n  ) => Header<TGenerics>\n  getHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getLeftHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getCenterHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getRightHeaderGroups: () => HeaderGroup<TGenerics>[]\n\n  getFooterGroups: () => HeaderGroup<TGenerics>[]\n  getLeftFooterGroups: () => HeaderGroup<TGenerics>[]\n  getCenterFooterGroups: () => HeaderGroup<TGenerics>[]\n  getRightFooterGroups: () => HeaderGroup<TGenerics>[]\n\n  getFlatHeaders: () => Header<TGenerics>[]\n  getLeftFlatHeaders: () => Header<TGenerics>[]\n  getCenterFlatHeaders: () => Header<TGenerics>[]\n  getRightFlatHeaders: () => Header<TGenerics>[]\n\n  getLeafHeaders: () => Header<TGenerics>[]\n  getLeftLeafHeaders: () => Header<TGenerics>[]\n  getCenterLeafHeaders: () => Header<TGenerics>[]\n  getRightLeafHeaders: () => Header<TGenerics>[]\n\n  getHeader: (id: string) => Header<TGenerics>\n\n  getHeaderGroupProps: <TGetter extends Getter<HeaderGroupProps>>(\n    id: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<HeaderGroupProps, TGetter>\n  getFooterGroupProps: <TGetter extends Getter<FooterGroupProps>>(\n    id: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<FooterGroupProps, TGetter>\n  getHeaderProps: <TGetter extends Getter<HeaderProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<HeaderProps, TGetter>\n  getFooterProps: <TGetter extends Getter<FooterProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<FooterProps, TGetter>\n  getTotalWidth: () => number\n}\n\n//\n\nexport const Headers = {\n  createRow: <TGenerics extends PartialGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): HeadersRow<TGenerics> => {\n    return {\n      _getAllVisibleCells: memo(\n        () => [\n          row\n            .getAllCells()\n            .filter(cell => cell.column.getIsVisible())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        _ => {\n          return row.getAllCells().filter(cell => cell.column.getIsVisible())\n        },\n        {\n          key: 'row._getAllVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getVisibleCells: memo(\n        () => [\n          row.getLeftVisibleCells(),\n          row.getCenterVisibleCells(),\n          row.getRightVisibleCells(),\n        ],\n        (left, center, right) => [...left, ...center, ...right],\n        {\n          key: 'row.getVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getCenterVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allCells, left, right) => {\n          const leftAndRight = [...(left ?? []), ...(right ?? [])]\n\n          return allCells.filter(d => !leftAndRight.includes(d.columnId))\n        },\n        {\n          key: 'row.getCenterVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getLeftVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.left,\n          ,\n        ],\n        (allCells, left) => {\n          const cells = (left ?? [])\n            .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n            .filter(Boolean)\n\n          return cells\n        },\n        {\n          key: 'row.getLeftVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getRightVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.right,\n        ],\n        (allCells, right) => {\n          const cells = (right ?? [])\n            .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n            .filter(Boolean)\n\n          return cells\n        },\n        {\n          key: 'row.getRightVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): HeadersInstance<TGenerics> => {\n    return {\n      createHeader: (\n        column: Column<TGenerics>,\n        options: {\n          id?: string\n          isPlaceholder?: boolean\n          placeholderId?: string\n          depth: number\n        }\n      ) => {\n        const id = options.id ?? column.id\n\n        let header: CoreHeader<TGenerics> = {\n          id,\n          column,\n          isPlaceholder: options.isPlaceholder,\n          placeholderId: options.placeholderId,\n          depth: options.depth,\n          subHeaders: [],\n          colSpan: 0,\n          rowSpan: 0,\n          getWidth: () => {\n            let sum = 0\n\n            const recurse = (header: CoreHeader<TGenerics>) => {\n              if (header.subHeaders.length) {\n                header.subHeaders.forEach(recurse)\n              } else {\n                sum += header.column.getWidth() ?? 0\n              }\n            }\n\n            recurse(header)\n\n            return sum\n          },\n          getLeafHeaders: (): Header<TGenerics>[] => {\n            const leafHeaders: CoreHeader<TGenerics>[] = []\n\n            const recurseHeader = (h: CoreHeader<TGenerics>) => {\n              if (h.subHeaders && h.subHeaders.length) {\n                h.subHeaders.map(recurseHeader)\n              }\n              leafHeaders.push(h)\n            }\n\n            recurseHeader(header)\n\n            return leafHeaders as Header<TGenerics>[]\n          },\n          getHeaderProps: userProps =>\n            instance.getHeaderProps(header.id, userProps)!,\n          getFooterProps: userProps =>\n            instance.getFooterProps(header.id, userProps)!,\n          renderHeader: () =>\n            flexRender(column.header, { instance, header, column }),\n          renderFooter: () =>\n            flexRender(column.footer, { instance, header, column }),\n        }\n\n        // Yes, we have to convert instance to unknown, because we know more than the compiler here.\n        return Object.assign(\n          header,\n          ColumnSizing.createHeader(header as Header<TGenerics>, instance)\n        ) as Header<TGenerics>\n      },\n\n      // Header Groups\n\n      getHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, left, right) => {\n          const leftColumns = leafColumns.filter(column =>\n            left?.includes(column.id)\n          )\n          const rightColumns = leafColumns.filter(column =>\n            right?.includes(column.id)\n          )\n          const centerColumns = leafColumns.filter(\n            column => !left?.includes(column.id) && !right?.includes(column.id)\n          )\n          const headerGroups = buildHeaderGroups(\n            allColumns,\n            [...leftColumns, ...centerColumns, ...rightColumns],\n            instance\n          )\n\n          return headerGroups\n        },\n        {\n          key: 'getHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, left, right) => {\n          leafColumns = leafColumns.filter(\n            column => !left?.includes(column.id) && !right?.includes(column.id)\n          )\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'center')\n        },\n        {\n          key: 'getCenterHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n        ],\n        (allColumns, leafColumns, left) => {\n          leafColumns = leafColumns.filter(column => left?.includes(column.id))\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'left')\n        },\n        {\n          key: 'getLeftHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, right) => {\n          leafColumns = leafColumns.filter(column => right?.includes(column.id))\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'right')\n        },\n        {\n          key: 'getRightHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Footer Groups\n\n      getFooterGroups: memo(\n        () => [instance.getHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftFooterGroups: memo(\n        () => [instance.getLeftHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getLeftFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterFooterGroups: memo(\n        () => [instance.getCenterHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getCenterFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightFooterGroups: memo(\n        () => [instance.getRightHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: 'getRightFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Flat Headers\n\n      getFlatHeaders: memo(\n        () => [instance.getHeaderGroups()],\n        headerGroups => {\n          return headerGroups\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftFlatHeaders: memo(\n        () => [instance.getLeftHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getLeftFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterFlatHeaders: memo(\n        () => [instance.getCenterHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getCenterFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightFlatHeaders: memo(\n        () => [instance.getRightHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: 'getRightFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Leaf Headers\n\n      getCenterLeafHeaders: memo(\n        () => [instance.getCenterFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: 'getCenterLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftLeafHeaders: memo(\n        () => [instance.getLeftFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: 'getLeftLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightLeafHeaders: memo(\n        () => [instance.getRightFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: 'getRightLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeafHeaders: memo(\n        () => [\n          instance.getLeftHeaderGroups(),\n          instance.getCenterHeaderGroups(),\n          instance.getRightHeaderGroups(),\n        ],\n        (left, center, right) => {\n          return [\n            ...(left[0]?.headers ?? []),\n            ...(center[0]?.headers ?? []),\n            ...(right[0]?.headers ?? []),\n          ]\n            .map(header => {\n              return header.getLeafHeaders()\n            })\n            .flat()\n        },\n        {\n          key: 'getLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getHeader: (id: string) => {\n        const header = [\n          ...instance.getFlatHeaders(),\n          ...instance.getCenterFlatHeaders(),\n          ...instance.getLeftFlatHeaders(),\n          ...instance.getRightFlatHeaders(),\n        ].find(d => d.id === id)\n\n        if (!header) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`Could not find header with id: ${id}`)\n          }\n          throw new Error()\n        }\n\n        return header\n      },\n\n      getHeaderGroupProps: (id, userProps) => {\n        const headerGroup = instance.getHeaderGroups().find(d => d.id === id)\n\n        if (!headerGroup) {\n          return\n        }\n\n        return propGetter(\n          {\n            key: headerGroup.id,\n            role: 'row',\n          },\n          userProps\n        )\n      },\n\n      getFooterGroupProps: (id, userProps) => {\n        const headerGroup = instance.getFooterGroups().find(d => d.id === id)\n\n        if (!headerGroup) {\n          return\n        }\n\n        const initialProps = {\n          key: headerGroup.id,\n          role: 'row',\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getHeaderProps: (id, userProps) => {\n        const header = instance.getHeader(id)\n\n        if (!header) {\n          throw new Error()\n        }\n\n        const initialProps: HeaderProps = {\n          key: header.id,\n          role: 'columnheader',\n          colSpan: header.colSpan,\n          rowSpan: header.rowSpan,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getFooterProps: (id, userProps) => {\n        const header = instance.getHeader(id)\n\n        const initialProps: FooterProps = {\n          key: header.id,\n          role: 'columnfooter',\n          colSpan: header.colSpan,\n          rowSpan: header.rowSpan,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getTotalWidth: () => {\n        let width = 0\n\n        instance.getVisibleLeafColumns().forEach(column => {\n          width += column.getWidth() ?? 0\n        })\n\n        return width\n      },\n    }\n  },\n}\n\nexport function buildHeaderGroups<TGenerics extends PartialGenerics>(\n  allColumns: Column<TGenerics>[],\n  columnsToGroup: Column<TGenerics>[],\n  instance: TableInstance<TGenerics>,\n  headerFamily?: 'center' | 'left' | 'right'\n) {\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0\n\n  const findMaxDepth = (columns: Column<TGenerics>[], depth = 1) => {\n    maxDepth = Math.max(maxDepth, depth)\n\n    columns\n      .filter(column => column.getIsVisible())\n      .forEach(column => {\n        if (column.columns?.length) {\n          findMaxDepth(column.columns, depth + 1)\n        }\n      }, 0)\n  }\n\n  findMaxDepth(allColumns)\n\n  let headerGroups: HeaderGroup<TGenerics>[] = []\n\n  const createHeaderGroup = (\n    headersToGroup: Header<TGenerics>[],\n    depth: number\n  ) => {\n    // The header group we are creating\n    const headerGroup: HeaderGroup<TGenerics> = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: [],\n      getHeaderGroupProps: getterValue =>\n        instance.getHeaderGroupProps(`${depth}`, getterValue)!,\n      getFooterGroupProps: getterValue =>\n        instance.getFooterGroupProps(`${depth}`, getterValue)!,\n    }\n\n    // The parent columns we're going to scan next\n    const parentHeaders: Header<TGenerics>[] = []\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestParentHeader = [...parentHeaders].reverse()[0]\n\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth\n\n      let column: Column<TGenerics>\n      let isPlaceholder = false\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column\n        isPlaceholder = true\n      }\n\n      const header = instance.createHeader(column, {\n        id: [headerFamily, depth, column.id, headerToGroup?.id]\n          .filter(Boolean)\n          .join('_'),\n        isPlaceholder,\n        placeholderId: isPlaceholder\n          ? `${parentHeaders.filter(d => d.column === column).length}`\n          : undefined,\n        depth,\n      })\n\n      if (!latestParentHeader || latestParentHeader.column !== header.column) {\n        header.subHeaders.push(headerToGroup)\n        parentHeaders.push(header)\n      } else {\n        latestParentHeader.subHeaders.push(headerToGroup)\n      }\n\n      // if (!headerToGroup.isPlaceholder) {\n      //   headerToGroup.column.header = headerToGroup;\n      // }\n\n      headerGroup.headers.push(headerToGroup)\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (depth > 0) {\n      createHeaderGroup(parentHeaders, depth - 1)\n    }\n  }\n\n  const bottomHeaders = columnsToGroup.map(column =>\n    instance.createHeader(column, {\n      depth: maxDepth,\n    })\n  )\n\n  createHeaderGroup(bottomHeaders, maxDepth - 1)\n\n  headerGroups.reverse()\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = (headers: Header<TGenerics>[]) => {\n    const filteredHeaders = headers.filter(header =>\n      header.column.getIsVisible()\n    )\n\n    return filteredHeaders.map(header => {\n      let colSpan = 0\n      let rowSpan = 0\n      let childRowSpans = [0]\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = []\n\n        recurseHeadersForSpans(header.subHeaders).forEach(\n          ({ colSpan: childColSpan, rowSpan: childRowSpan }) => {\n            colSpan += childColSpan\n            childRowSpans.push(childRowSpan)\n          }\n        )\n      } else {\n        colSpan = 1\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans)\n      rowSpan = rowSpan + minChildRowSpan\n\n      header.colSpan = colSpan > 0 ? colSpan : undefined\n      header.rowSpan = rowSpan > 0 ? rowSpan : undefined\n\n      return { colSpan, rowSpan }\n    })\n  }\n\n  recurseHeadersForSpans(headerGroups[0]?.headers ?? [])\n\n  return headerGroups\n}\n", "import { PartialGenerics, Row } from './types'\n\nexport const filterTypes = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  equalsStringSensitive,\n  arrIncludes,\n  arrIncludesAll,\n  equals,\n  weakEquals,\n  betweenNumberRange,\n}\n\nexport type BuiltInFilterType = keyof typeof filterTypes\n\nfunction includesString<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue).toLowerCase()\n\n  rows = rows.filter(row => {\n    return columnIds.some(id => {\n      return String(row.values[id]).toLowerCase().includes(search)\n    })\n  })\n  return rows\n}\n\nincludesString.autoRemove = (val: any) => testFalsey(val)\n\nfunction includesStringSensitive<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue)\n\n  rows = rows.filter(row => {\n    return columnIds.some(id => {\n      return String(row.values[id]).includes(search)\n    })\n  })\n  return rows\n}\n\nincludesStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nfunction equalsString<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue).toLowerCase()\n\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue !== undefined\n        ? String(rowValue).toLowerCase() === search\n        : true\n    })\n  })\n}\n\nequalsString.autoRemove = (val: any) => testFalsey(val)\n\nfunction equalsStringSensitive<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue)\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue !== undefined ? String(rowValue) === search : true\n    })\n  })\n}\n\nequalsStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nfunction arrIncludes<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue.includes(filterValue)\n    })\n  })\n}\n\narrIncludes.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nfunction arrIncludesAll<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown[]\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return (\n        rowValue &&\n        rowValue.length &&\n        filterValue.every(val => rowValue.includes(val))\n      )\n    })\n  })\n}\n\narrIncludesAll.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nfunction equals<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue === filterValue\n    })\n  })\n}\n\nequals.autoRemove = (val: any) => testFalsey(val)\n\nfunction weakEquals<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      // eslint-disable-next-line eqeqeq\n      return rowValue == filterValue\n    })\n  })\n}\n\nweakEquals.autoRemove = (val: any) => testFalsey(val)\n\nfunction betweenNumberRange<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnIds: string[],\n  filterValue: [unknown, unknown]\n) {\n  let [unsafeMin, unsafeMax] = filterValue || []\n\n  let parsedMin =\n    typeof unsafeMin !== 'number' ? parseFloat(unsafeMin as string) : unsafeMin\n  let parsedMax =\n    typeof unsafeMax !== 'number' ? parseFloat(unsafeMax as string) : unsafeMax\n\n  let min =\n    unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue >= min && rowValue <= max\n    })\n  })\n}\n\nbetweenNumberRange.autoRemove = (val: any) =>\n  testFalsey(val) || (testFalsey(val[0]) && testFalsey(val[1]))\n\n// Utils\n\nfunction testFalsey(val: any) {\n  return val === undefined || val === null || val === ''\n}\n", "import { RowModel } from '..'\nimport { BuiltInFilterType, filterTypes } from '../filterTypes'\nimport {\n  Column,\n  OnChangeFn,\n  PartialGenerics,\n  TableInstance,\n  Row,\n  Updater,\n} from '../types'\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n} from '../utils'\n\nexport type ColumnFilter = {\n  id: string\n  value: unknown\n}\n\nexport type ColumnFiltersState = ColumnFilter[]\n\nexport type FilterFn<TGenerics extends PartialGenerics> = {\n  (rows: Row<TGenerics>[], columnIds: string[], filterValue: any): any\n  autoRemove?: ColumnFilterAutoRemoveTestFn<TGenerics>\n}\n\nexport type ColumnFilterAutoRemoveTestFn<TGenerics extends PartialGenerics> = (\n  value: unknown,\n  column?: Column<TGenerics>\n) => boolean\n\nexport type CustomFilterTypes<TGenerics extends PartialGenerics> = Record<\n  string,\n  FilterFn<TGenerics>\n>\n\nexport type FiltersTableState = {\n  columnFilters: ColumnFiltersState\n  globalFilter: any\n}\n\nexport type FilterType<TGenerics extends PartialGenerics> =\n  | 'auto'\n  | BuiltInFilterType\n  | TGenerics['FilterFns']\n  | FilterFn<TGenerics>\n\nexport type FiltersColumnDef<TGenerics extends PartialGenerics> = {\n  filterType?: FilterType<Overwrite<TGenerics, { Value: any }>>\n  enableAllFilters?: boolean\n  enableColumnFilter?: boolean\n  enableGlobalFilter?: boolean\n  defaultCanFilter?: boolean\n  defaultCanColumnFilter?: boolean\n  defaultCanGlobalFilter?: boolean\n}\n\nexport type FiltersColumn<TGenerics extends PartialGenerics> = {\n  filterType: FilterType<Overwrite<TGenerics, { Value: any }>>\n  getCanColumnFilter: () => boolean\n  getCanGlobalFilter: () => boolean\n  getColumnFilterIndex: () => number\n  getIsColumnFiltered: () => boolean\n  getColumnFilterValue: () => unknown\n  setColumnFilterValue: (value: any) => void\n  getPreFilteredRows: () => Row<TGenerics>[] | undefined\n  getPreFilteredUniqueValues: () => Map<any, number>\n  getPreFilteredMinMaxValues: () => [any, any]\n}\n\nexport type FiltersOptions<TGenerics extends PartialGenerics> = {\n  filterFromChildrenUp?: boolean\n  filterTypes?: TGenerics['FilterFns']\n  enableFilters?: boolean\n  // Column\n  onColumnFiltersChange?: OnChangeFn<ColumnFiltersState>\n  autoResetColumnFilters?: boolean\n  enableColumnFilters?: boolean\n  columnFilterRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    coreRowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  // Global\n  globalFilterType?: FilterType<TGenerics>\n  onGlobalFilterChange?: OnChangeFn<any>\n  enableGlobalFilters?: boolean\n  autoResetGlobalFilter?: boolean\n  enableGlobalFilter?: boolean\n  globalFilterRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  getColumnCanGlobalFilterFn?: (column: Column<TGenerics>) => boolean\n}\n\nexport type FiltersInstance<TGenerics extends PartialGenerics> = {\n  _notifyFiltersReset: () => void\n  getColumnAutoFilterFn: (columnId: string) => FilterFn<TGenerics> | undefined\n\n  getColumnFilterFn: (columnId: string) => FilterFn<TGenerics> | undefined\n\n  setColumnFilters: (updater: Updater<ColumnFiltersState>) => void\n  setColumnFilterValue: (columnId: string, value: any) => void\n  resetColumnFilters: () => void\n  getColumnCanColumnFilter: (columnId: string) => boolean\n  getColumnCanGlobalFilterFn?: (column: Column<TGenerics>) => boolean\n\n  getColumnIsFiltered: (columnId: string) => boolean\n  getColumnFilterValue: (columnId: string) => unknown\n  getColumnFilterIndex: (columnId: string) => number\n\n  // All\n  getPreFilteredRowModel: () => RowModel<TGenerics>\n\n  // Column Filters\n  getPreColumnFilteredRowModel: () => RowModel<TGenerics>\n  getColumnFilteredRowModel: () => RowModel<TGenerics>\n\n  // Global Filters\n  setGlobalFilter: (updater: Updater<any>) => void\n  resetGlobalFilter: () => void\n  getGlobalAutoFilterFn: () => FilterFn<TGenerics> | undefined\n  getGlobalFilterFn: () => FilterFn<TGenerics> | undefined\n  getColumnCanGlobalFilter: (columnId: string) => boolean\n  getPreGlobalFilteredRowModel: () => RowModel<TGenerics>\n  getGlobalFilteredRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport function getDefaultColumn<\n  TGenerics extends PartialGenerics\n>(): FiltersColumnDef<TGenerics> {\n  return {\n    filterType: 'auto',\n  }\n}\n\nexport const Filters = {\n  getInitialState: (): FiltersTableState => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): FiltersOptions<TGenerics> => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n      autoResetColumnFilters: true,\n      filterFromChildrenUp: true,\n      autoResetGlobalFilter: true,\n      globalFilterType: 'auto',\n      getColumnCanGlobalFilterFn: column => {\n        const value = instance\n          .getCoreRowModel()\n          .flatRows[0]?.getAllCellsByColumnId()[column.id]?.value\n\n        return typeof value === 'string'\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends PartialGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): FiltersColumn<TGenerics> => {\n    const getFacetInfo = memo(\n      () => [column.getPreFilteredRows()],\n      (rows = []) => {\n        let preFilteredUniqueValues = new Map<any, number>()\n\n        let preFilteredMinMaxValues: [any, any] = [\n          rows[0]?.values[column.id] ?? null,\n          rows[0]?.values[column.id] ?? null,\n        ]\n\n        for (let i = 0; i < rows.length; i++) {\n          const value = rows[i]?.values[column.id]\n\n          if (preFilteredUniqueValues.has(value)) {\n            preFilteredUniqueValues.set(\n              value,\n              (preFilteredUniqueValues.get(value) ?? 0) + 1\n            )\n          } else {\n            preFilteredUniqueValues.set(value, 1)\n          }\n\n          if (value < preFilteredMinMaxValues[0]) {\n            preFilteredMinMaxValues[0] = value\n          } else if (value > preFilteredMinMaxValues[1]) {\n            preFilteredMinMaxValues[1] = value\n          }\n        }\n\n        return {\n          preFilteredUniqueValues,\n          preFilteredMinMaxValues,\n        }\n      },\n      {\n        key: 'column.getFacetInfo',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    )\n\n    return {\n      filterType: column.filterType,\n      getCanColumnFilter: () => instance.getColumnCanColumnFilter(column.id),\n      getCanGlobalFilter: () => instance.getColumnCanGlobalFilter(column.id),\n      getColumnFilterIndex: () => instance.getColumnFilterIndex(column.id),\n      getIsColumnFiltered: () => instance.getColumnIsFiltered(column.id),\n      getColumnFilterValue: () => instance.getColumnFilterValue(column.id),\n      setColumnFilterValue: val =>\n        instance.setColumnFilterValue(column.id, val),\n      getPreFilteredUniqueValues: () => getFacetInfo().preFilteredUniqueValues,\n      getPreFilteredMinMaxValues: () => getFacetInfo().preFilteredMinMaxValues,\n      getPreFilteredRows: () => undefined,\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): FiltersInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifyFiltersReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (instance.options.autoResetAll === true) {\n          instance.resetSorting()\n        } else {\n          if (instance.options.autoResetColumnFilters) {\n            instance.resetColumnFilters()\n          }\n          if (instance.options.autoResetGlobalFilter) {\n            instance.resetGlobalFilter()\n          }\n        }\n      },\n      getColumnAutoFilterFn: columnId => {\n        const firstRow = instance.getCoreRowModel().flatRows[0]\n\n        const value = firstRow?.values[columnId]\n\n        if (typeof value === 'string') {\n          return filterTypes.includesString\n        }\n\n        if (typeof value === 'number') {\n          return filterTypes.betweenNumberRange\n        }\n\n        if (value !== null && typeof value === 'object') {\n          return filterTypes.equals\n        }\n\n        if (Array.isArray(value)) {\n          return filterTypes.arrIncludes\n        }\n\n        return filterTypes.weakEquals\n      },\n      getGlobalAutoFilterFn: () => {\n        return filterTypes.includesString\n      },\n      getColumnFilterFn: columnId => {\n        const column = instance.getColumn(columnId)\n        const userFilterTypes = instance.options.filterTypes\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.filterType)\n          ? column.filterType\n          : column.filterType === 'auto'\n          ? instance.getColumnAutoFilterFn(columnId)\n          : (userFilterTypes as Record<string, any>)?.[\n              column.filterType as string\n            ] ??\n            (filterTypes[\n              column.filterType as BuiltInFilterType\n            ] as FilterFn<TGenerics>)\n      },\n\n      getGlobalFilterFn: () => {\n        const { filterTypes: userFilterTypes, globalFilterType } =\n          instance.options\n\n        return isFunction(globalFilterType)\n          ? globalFilterType\n          : globalFilterType === 'auto'\n          ? instance.getGlobalAutoFilterFn()\n          : (userFilterTypes as Record<string, any>)?.[\n              globalFilterType as string\n            ] ??\n            (filterTypes[\n              globalFilterType as BuiltInFilterType\n            ] as FilterFn<TGenerics>)\n      },\n\n      setColumnFilters: (updater: Updater<ColumnFiltersState>) => {\n        const leafColumns = instance.getAllLeafColumns()\n\n        const updateFn = (old: ColumnFiltersState) => {\n          return functionalUpdate(updater, old)?.filter(filter => {\n            const column = leafColumns.find(d => d.id === filter.id)\n\n            if (column) {\n              const filterFn = instance.getColumnFilterFn(column.id)\n\n              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                return false\n              }\n            }\n\n            return true\n          })\n        }\n\n        instance.options.onColumnFiltersChange?.(\n          updateFn,\n          updateFn(instance.getState().columnFilters)\n        )\n      },\n\n      setGlobalFilter: updater => {\n        instance.options.onGlobalFilterChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().globalFilter)\n        )\n      },\n\n      resetGlobalFilter: () => {\n        instance.setGlobalFilter(undefined)\n      },\n\n      getColumnCanColumnFilter: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableAllFilters ??\n          column.enableColumnFilter ??\n          instance.options.enableFilters ??\n          instance.options.enableColumnFilters ??\n          column.defaultCanFilter ??\n          column.defaultCanColumnFilter ??\n          !!column.accessorFn\n        )\n      },\n\n      getColumnCanGlobalFilter: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          ((instance.options.enableFilters ??\n            instance.options.enableGlobalFilter ??\n            column.enableAllFilters ??\n            column.enableGlobalFilter ??\n            column.defaultCanFilter ??\n            column.defaultCanGlobalFilter ??\n            !!column.accessorFn) &&\n            instance.options.getColumnCanGlobalFilterFn?.(column)) ??\n          true\n        )\n      },\n\n      getColumnIsFiltered: columnId =>\n        instance.getColumnFilterIndex(columnId) > -1,\n\n      getColumnFilterValue: columnId =>\n        instance.getState().columnFilters?.find(d => d.id === columnId)?.value,\n\n      getColumnFilterIndex: columnId =>\n        instance.getState().columnFilters?.findIndex(d => d.id === columnId) ??\n        -1,\n\n      setColumnFilterValue: (columnId, value) => {\n        if (!columnId) return\n\n        instance.setColumnFilters(old => {\n          const column = instance.getColumn(columnId)\n\n          if (!column) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(\n                `React-Table: Could not find a column with id: ${columnId}`\n              )\n            }\n            throw new Error()\n          }\n\n          const filterFn = instance.getColumnFilterFn(column.id)\n          const previousfilter = old?.find(d => d.id === columnId)\n\n          const newFilter = functionalUpdate(\n            value,\n            previousfilter ? previousfilter.value : undefined\n          )\n\n          //\n          if (\n            shouldAutoRemoveFilter(\n              filterFn as FilterFn<TGenerics>,\n              newFilter,\n              column\n            )\n          ) {\n            return old?.filter(d => d.id !== columnId) ?? []\n          }\n\n          const newFilterObj = { id: columnId, value: newFilter }\n\n          if (previousfilter) {\n            return (\n              old?.map(d => {\n                if (d.id === columnId) {\n                  return newFilterObj\n                }\n                return d\n              }) ?? []\n            )\n          }\n\n          if (old?.length) {\n            return [...old, newFilterObj]\n          }\n\n          return [newFilterObj]\n        })\n      },\n\n      resetColumnFilters: () => {\n        instance.setColumnFilters(instance.initialState?.columnFilters ?? [])\n      },\n\n      getPreFilteredRowModel: () => instance.getCoreRowModel(),\n      getPreColumnFilteredRowModel: () => instance.getCoreRowModel(),\n      getColumnFilteredRowModel: memo(\n        () => [\n          instance.getState().columnFilters,\n          instance.getCoreRowModel(),\n          instance.options.columnFilterRowsFn,\n        ],\n        (columnFilters, rowModel, columnFiltersFn) => {\n          const columnFilteredRowModel = (() => {\n            if (!columnFilters?.length || !columnFiltersFn) {\n              return rowModel\n            }\n\n            return columnFiltersFn(instance as any, rowModel)\n          })()\n\n          // Now that each filtered column has it's partially filtered rows,\n          // lets assign the final filtered rows to all of the other columns\n          const nonFilteredColumns = instance\n            .getAllLeafColumns()\n            .filter(\n              column =>\n                !instance\n                  .getState()\n                  .columnFilters?.find(d => d.id === column.id)\n            )\n\n          // This essentially enables faceted filter options to be built easily\n          // using every column's preFilteredRows value\n\n          nonFilteredColumns.forEach(column => {\n            column.getPreFilteredRows = () => columnFilteredRowModel.rows\n          })\n\n          return columnFilteredRowModel\n        },\n        {\n          key: 'getColumnFilteredRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n      getPreGlobalFilteredRowModel: () => instance.getColumnFilteredRowModel(),\n      getGlobalFilteredRowModel: memo(\n        () => [\n          instance.getState().globalFilter,\n          instance.getColumnFilteredRowModel(),\n          instance.options.globalFilterRowsFn,\n        ],\n        (globalFilterValue, columnFilteredRowModel, globalFiltersFn) => {\n          const globalFilteredRowModel = (() => {\n            if (!globalFiltersFn || !globalFilterValue) {\n              return columnFilteredRowModel\n            }\n\n            return globalFiltersFn(\n              instance as TableInstance<TGenerics>,\n              columnFilteredRowModel\n            )\n          })()\n\n          // Now that each filtered column has it's partially filtered rows,\n          // lets assign the final filtered rows to all of the other columns\n          const nonFilteredColumns = instance\n            .getAllLeafColumns()\n            .filter(\n              column =>\n                !instance\n                  .getState()\n                  .columnFilters?.find(d => d.id === column.id)\n            )\n\n          // This essentially enables faceted filter options to be built easily\n          // using every column's preFilteredRows value\n\n          nonFilteredColumns.forEach(column => {\n            column.getPreFilteredRows = () => globalFilteredRowModel.rows\n          })\n\n          return globalFilteredRowModel\n        },\n        {\n          key: 'getGlobalFilteredRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => {\n            instance._notifySortingReset()\n          },\n        }\n      ),\n    }\n  },\n}\n\nexport function shouldAutoRemoveFilter<TGenerics extends PartialGenerics>(\n  filterFn?: FilterFn<TGenerics>,\n  value?: any,\n  column?: Column<TGenerics>\n) {\n  return (\n    (filterFn && filterFn.autoRemove\n      ? filterFn.autoRemove(value, column)\n      : false) ||\n    typeof value === 'undefined' ||\n    (typeof value === 'string' && !value)\n  )\n}\n", "import { PartialGenerics, Row } from './types'\n\nexport const reSplitAlphaNumeric = /([0-9]+)/gm\n\nexport const sortTypes = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic,\n}\n\nexport type BuiltInSortType = keyof typeof sortTypes\n\nfunction alphanumeric<TGenerics extends PartialGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.values[columnId]).toLowerCase(),\n    toString(rowB.values[columnId]).toLowerCase()\n  )\n}\n\nfunction alphanumericCaseSensitive<TGenerics extends PartialGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.values[columnId]),\n    toString(rowB.values[columnId])\n  )\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr: string, bStr: string) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean)\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift()!\n    const bb = b.shift()!\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0]!)) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1]!)) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction text<TGenerics extends PartialGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.values[columnId]).toLowerCase(),\n    toString(rowB.values[columnId]).toLowerCase()\n  )\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction textCaseSensitive<TGenerics extends PartialGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.values[columnId]),\n    toString(rowB.values[columnId])\n  )\n}\n\nfunction datetime<TGenerics extends PartialGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    (rowA.values[columnId] as Date).getTime(),\n    (rowB.values[columnId] as Date).getTime()\n  )\n}\n\nfunction basic<TGenerics extends PartialGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(rowA.values[columnId], rowB.values[columnId])\n}\n\n// Utils\n\nfunction compareBasic(a: any, b: any) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction toString(a: any) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n", "import { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport { BuiltInSortType, reSplitAlphaNumeric, sortTypes } from '../sortTypes'\n\nimport {\n  Column,\n  Getter,\n  Header,\n  OnChangeFn,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  Updater,\n} from '../types'\n\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n  propGetter,\n} from '../utils'\n\nexport type SortDirection = 'asc' | 'desc'\n\nexport type ColumnSort = {\n  id: string\n  desc: boolean\n}\n\nexport type SortingState = ColumnSort[]\n\nexport type SortingFn<TGenerics extends PartialGenerics> = {\n  (rowA: Row<TGenerics>, rowB: Row<TGenerics>, columnId: string): number\n}\n\nexport type CustomSortingTypes<TGenerics extends PartialGenerics> = Record<\n  string,\n  SortingFn<TGenerics>\n>\n\nexport type SortingTableState = {\n  sorting: SortingState\n}\n\nexport type SortType<TGenerics extends PartialGenerics> =\n  | 'auto'\n  | BuiltInSortType\n  | keyof TGenerics['SortingFns']\n  | SortingFn<TGenerics>\n\nexport type SortingColumnDef<TGenerics extends PartialGenerics> = {\n  sortType?: SortType<Overwrite<TGenerics, { Value: any }>>\n  sortDescFirst?: boolean\n  enableSorting?: boolean\n  enableMultiSort?: boolean\n  defaultCanSort?: boolean\n  invertSorting?: boolean\n  sortUndefined?: false | -1 | 1\n}\n\nexport type SortingColumn<TGenerics extends PartialGenerics> = {\n  sortType: SortType<Overwrite<TGenerics, { Value: any }>>\n  getCanSort: () => boolean\n  getCanMultiSort: () => boolean\n  getSortIndex: () => number\n  getIsSorted: () => false | SortDirection\n  toggleSorting: (desc?: boolean, isMulti?: boolean) => void\n  getToggleSortingProps: <TGetter extends Getter<ToggleSortingProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleSortingProps, TGetter>\n}\n\nexport type SortingOptions<TGenerics extends PartialGenerics> = {\n  sortTypes?: TGenerics['SortingFns']\n  onSortingChange?: OnChangeFn<SortingState>\n  autoResetSorting?: boolean\n  enableSorting?: boolean\n  enableSortingRemoval?: boolean\n  enableMultiRemove?: boolean\n  enableMultiSort?: boolean\n  sortDescFirst?: boolean\n  sortRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  maxMultiSortColCount?: number\n  isMultiSortEvent?: (e: MouseEvent | TouchEvent) => boolean\n}\n\nexport type ToggleSortingProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type SortingInstance<TGenerics extends PartialGenerics> = {\n  _notifySortingReset: () => void\n  getColumnAutoSortingFn: (columnId: string) => SortingFn<TGenerics> | undefined\n  getColumnAutoSortDir: (columnId: string) => SortDirection\n\n  getColumnSortingFn: (columnId: string) => SortingFn<TGenerics> | undefined\n\n  setSorting: (updater: Updater<SortingState>) => void\n  toggleColumnSorting: (\n    columnId: string,\n    desc?: boolean,\n    multi?: boolean\n  ) => void\n  resetSorting: () => void\n  getColumnCanSort: (columnId: string) => boolean\n  getColumnCanMultiSort: (columnId: string) => boolean\n  getColumnIsSorted: (columnId: string) => false | 'asc' | 'desc'\n  getColumnSortIndex: (columnId: string) => number\n  getToggleSortingProps: <TGetter extends Getter<ToggleSortingProps>>(\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleSortingProps, TGetter>\n  getPreSortedRowModel: () => RowModel<TGenerics>\n  getSortedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Sorting = {\n  getDefaultColumn: <\n    TGenerics extends PartialGenerics\n  >(): SortingColumnDef<TGenerics> => {\n    return {\n      sortType: 'auto',\n    }\n  },\n\n  getInitialState: (): SortingTableState => {\n    return {\n      sorting: [],\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): SortingOptions<TGenerics> => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', instance),\n      autoResetSorting: true,\n      isMultiSortEvent: (e: MouseEvent | TouchEvent) => {\n        return e.shiftKey\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends PartialGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): SortingColumn<TGenerics> => {\n    return {\n      sortType: column.sortType,\n      getCanSort: () => instance.getColumnCanSort(column.id),\n      getCanMultiSort: () => instance.getColumnCanMultiSort(column.id),\n      getSortIndex: () => instance.getColumnSortIndex(column.id),\n      getIsSorted: () => instance.getColumnIsSorted(column.id),\n      toggleSorting: (desc, isMulti) =>\n        instance.toggleColumnSorting(column.id, desc, isMulti),\n      getToggleSortingProps: userProps =>\n        instance.getToggleSortingProps(column.id, userProps),\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): SortingInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifySortingReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetSorting\n        ) {\n          instance.resetSorting()\n        }\n      },\n      getColumnAutoSortingFn: columnId => {\n        const firstRows = instance\n          .getGlobalFilteredRowModel()\n          .flatRows.slice(100)\n\n        let isString = false\n\n        for (const row of firstRows) {\n          const value = row?.values[columnId]\n\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return sortTypes.datetime\n          }\n\n          if (typeof value === 'string') {\n            isString = true\n\n            if (value.split(reSplitAlphaNumeric).length > 1) {\n              return sortTypes.alphanumeric\n            }\n          }\n        }\n\n        if (isString) {\n          return sortTypes.text\n        }\n\n        return sortTypes.basic\n      },\n      getColumnAutoSortDir: columnId => {\n        const firstRow = instance.getGlobalFilteredRowModel().flatRows[0]\n\n        const value = firstRow?.values[columnId]\n\n        if (typeof value === 'string') {\n          return 'asc'\n        }\n\n        return 'desc'\n      },\n      getColumnSortingFn: columnId => {\n        const column = instance.getColumn(columnId)\n        const userSortTypes = instance.options.sortTypes\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.sortType)\n          ? column.sortType\n          : column.sortType === 'auto'\n          ? instance.getColumnAutoSortingFn(columnId)\n          : (userSortTypes as Record<string, any>)?.[\n              column.sortType as string\n            ] ??\n            (sortTypes[\n              column.sortType as BuiltInSortType\n            ] as SortingFn<TGenerics>)\n      },\n\n      setSorting: updater =>\n        instance.options.onSortingChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().sorting)\n        ),\n\n      toggleColumnSorting: (columnId, desc, multi) => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        // if (column.columns.length) {\n        //   column.columns.forEach((c, i) => {\n        //     if (c.id) {\n        //       instance.toggleColumnSorting(c.id, undefined, multi || !!i)\n        //     }\n        //   })\n        //   return\n        // }\n\n        instance.setSorting(old => {\n          // Find any existing sorting for this column\n          const existingSorting = old?.find(d => d.id === columnId)\n          const existingIndex = old?.findIndex(d => d.id === columnId)\n          const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n          let newSorting: SortingState = []\n\n          // What should we do with this sort action?\n          let sortAction\n\n          if (column.getCanMultiSort() && multi) {\n            if (existingSorting) {\n              sortAction = 'toggle'\n            } else {\n              sortAction = 'add'\n            }\n          } else {\n            // Normal mode\n            if (old?.length && existingIndex !== old.length - 1) {\n              sortAction = 'replace'\n            } else if (existingSorting) {\n              sortAction = 'toggle'\n            } else {\n              sortAction = 'replace'\n            }\n          }\n\n          const sortDescFirst =\n            column.sortDescFirst ??\n            instance.options.sortDescFirst ??\n            instance.getColumnAutoSortDir(columnId) === 'desc'\n\n          // Handle toggle states that will remove the sorting\n          if (\n            sortAction === 'toggle' && // Must be toggling\n            (instance.options.enableSortingRemoval ?? true) && // If enableSortRemove, enable in general\n            !hasDescDefined && // Must not be setting desc\n            (multi ? instance.options.enableMultiRemove ?? true : true) && // If multi, don't allow if enableMultiRemove\n            (existingSorting?.desc // Finally, detect if it should indeed be removed\n              ? !sortDescFirst\n              : sortDescFirst)\n          ) {\n            sortAction = 'remove'\n          }\n\n          if (sortAction === 'replace') {\n            newSorting = [\n              {\n                id: columnId,\n                desc: hasDescDefined ? desc! : !!sortDescFirst,\n              },\n            ]\n          } else if (sortAction === 'add' && old?.length) {\n            newSorting = [\n              ...old,\n              {\n                id: columnId,\n                desc: hasDescDefined ? desc! : !!sortDescFirst,\n              },\n            ]\n            // Take latest n columns\n            newSorting.splice(\n              0,\n              newSorting.length -\n                (instance.options.maxMultiSortColCount ??\n                  Number.MAX_SAFE_INTEGER)\n            )\n          } else if (sortAction === 'toggle' && old?.length) {\n            // This flips (or sets) the\n            newSorting = old.map(d => {\n              if (d.id === columnId) {\n                return {\n                  ...d,\n                  desc: hasDescDefined ? desc! : !existingSorting?.desc,\n                }\n              }\n              return d\n            })\n          } else if (sortAction === 'remove' && old?.length) {\n            newSorting = old.filter(d => d.id !== columnId)\n          }\n\n          return newSorting\n        })\n      },\n\n      getColumnCanSort: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableSorting ??\n          instance.options.enableSorting ??\n          column.defaultCanSort ??\n          !!column.accessorFn\n          // (!!column.accessorFn ||\n          //   column.columns?.some(c => c.id && instance.getColumnCanSort(c.id))) ??\n          // false\n        )\n      },\n\n      getColumnCanMultiSort: columnId => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return (\n          column.enableMultiSort ??\n          instance.options.enableMultiSort ??\n          !!column.accessorFn\n        )\n      },\n\n      getColumnIsSorted: columnId => {\n        const columnSort = instance\n          .getState()\n          .sorting?.find(d => d.id === columnId)\n\n        return !columnSort ? false : columnSort.desc ? 'desc' : 'asc'\n      },\n\n      getColumnSortIndex: columnId =>\n        instance.getState().sorting?.findIndex(d => d.id === columnId) ?? -1,\n\n      resetSorting: () => {\n        instance.setSorting(instance.initialState?.sorting ?? [])\n      },\n\n      getToggleSortingProps: (columnId, userProps) => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          throw new Error()\n        }\n\n        const canSort = column.getCanSort()\n\n        const initialProps: ToggleSortingProps = {\n          title: canSort ? 'Toggle Sorting' : undefined,\n          onClick: canSort\n            ? (e: MouseEvent | TouchEvent) => {\n                e.persist()\n                column.toggleSorting?.(\n                  undefined,\n                  column.getCanMultiSort()\n                    ? instance.options.isMultiSortEvent?.(e)\n                    : false\n                )\n              }\n            : undefined,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getPreSortedRowModel: () => instance.getGlobalFilteredRowModel(),\n      getSortedRowModel: memo(\n        () => [\n          instance.getState().sorting,\n          instance.getGlobalFilteredRowModel(),\n          instance.options.sortRowsFn,\n        ],\n        (sorting, rowModel, sortingFn) => {\n          if (!sortingFn || !sorting?.length) {\n            return rowModel\n          }\n\n          return sortingFn(instance, rowModel)\n        },\n        {\n          key: 'getSortedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => {\n            instance._notifyGroupingReset()\n          },\n        }\n      ),\n    }\n  },\n}\n", "import { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport {\n  Getter,\n  OnChangeFn,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type ExpandedStateList = Record<string, boolean>\nexport type ExpandedState = true | Record<string, boolean>\nexport type ExpandedTableState = {\n  expanded: ExpandedState\n}\n\nexport type ExpandedRow = {\n  toggleExpanded: (expanded?: boolean) => void\n  getIsExpanded: () => boolean\n  getCanExpand: () => boolean\n  getToggleExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n}\n\nexport type ExpandedOptions<TGenerics extends PartialGenerics> = {\n  onExpandedChange?: OnChangeFn<ExpandedState>\n  autoResetExpanded?: boolean\n  enableExpanded?: boolean\n  expandRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n  expandSubRows?: boolean\n  defaultCanExpand?: boolean\n  getIsRowExpanded?: (row: Row<TGenerics>) => boolean\n  getRowCanExpand?: (row: Row<TGenerics>) => boolean\n  paginateExpandedRows?: boolean\n}\n\nexport type ToggleExpandedProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type ExpandedInstance<TGenerics extends PartialGenerics> = {\n  _notifyExpandedReset: () => void\n  setExpanded: (updater: Updater<ExpandedState>) => void\n  toggleRowExpanded: (rowId: string, expanded?: boolean) => void\n  toggleAllRowsExpanded: (expanded?: boolean) => void\n  resetExpanded: () => void\n  getRowCanExpand: (rowId: string) => boolean\n  getIsRowExpanded: (rowId: string) => boolean\n  getToggleExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n  getToggleAllRowsExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n  getIsAllRowsExpanded: () => boolean\n  getExpandedDepth: () => number\n  getExpandedRowModel: () => RowModel<TGenerics>\n  getPreExpandedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Expanding = {\n  getInitialState: (): ExpandedTableState => {\n    return {\n      expanded: {},\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ExpandedOptions<TGenerics> => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', instance),\n      autoResetExpanded: true,\n      getIsRowExpanded: row => !!(row?.original as { expanded?: any }).expanded,\n      expandSubRows: true,\n      paginateExpandedRows: true,\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ExpandedInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      _notifyExpandedReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetExpanded\n        ) {\n          instance.resetExpanded()\n        }\n      },\n      setExpanded: updater =>\n        instance.options.onExpandedChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().expanded)\n        ),\n      toggleRowExpanded: (rowId, expanded) => {\n        if (!rowId) return\n\n        instance.setExpanded(old => {\n          const exists = old === true ? true : !!old?.[rowId]\n\n          let oldExpanded: ExpandedStateList = {}\n\n          if (old === true) {\n            Object.keys(instance.getRowModel().rowsById).forEach(rowId => {\n              oldExpanded[rowId] = true\n            })\n          } else {\n            oldExpanded = old\n          }\n\n          expanded = expanded ?? !exists\n\n          if (!exists && expanded) {\n            return {\n              ...oldExpanded,\n              [rowId]: true,\n            }\n          }\n\n          if (exists && !expanded) {\n            const { [rowId]: _, ...rest } = oldExpanded\n            return rest\n          }\n\n          return old\n        })\n      },\n      toggleAllRowsExpanded: expanded => {\n        if (expanded ?? !instance.getIsAllRowsExpanded()) {\n          instance.setExpanded(true)\n        } else {\n          instance.setExpanded({})\n        }\n      },\n      resetExpanded: () => {\n        instance.setExpanded(instance.initialState?.expanded ?? {})\n      },\n      getIsRowExpanded: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `[ReactTable] getIsRowExpanded: no row found with id ${rowId}`\n            )\n          }\n          throw new Error()\n        }\n\n        const expanded = instance.getState().expanded\n\n        return !!(\n          instance.options.getIsRowExpanded?.(row) ??\n          (expanded || expanded?.[rowId])\n        )\n      },\n      getRowCanExpand: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `[ReactTable] getRowCanExpand: no row found with id ${rowId}`\n            )\n          }\n          throw new Error()\n        }\n\n        return (\n          instance.options.getRowCanExpand?.(row) ??\n          instance.options.enableExpanded ??\n          instance.options.defaultCanExpand ??\n          !!row.subRows?.length\n        )\n      },\n      getToggleExpandedProps: (rowId, userProps) => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          return\n        }\n\n        const canExpand = instance.getRowCanExpand(rowId)\n\n        const initialProps: ToggleExpandedProps = {\n          title: canExpand ? 'Toggle Expanded' : undefined,\n          onClick: canExpand\n            ? (e: MouseEvent | TouchEvent) => {\n                e.persist()\n                instance.toggleRowExpanded(rowId)\n              }\n            : undefined,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n      getToggleAllRowsExpandedProps: userProps => {\n        const initialProps: ToggleExpandedProps = {\n          title: 'Toggle All Expanded',\n          onClick: (e: MouseEvent | TouchEvent) => {\n            e.persist()\n            instance.toggleAllRowsExpanded()\n          },\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n      getIsAllRowsExpanded: () => {\n        const expanded = instance.getState().expanded\n\n        // If expanded is true, save some cycles and return true\n        if (expanded === true) {\n          return true\n        }\n\n        // If any row is not expanded, return false\n        if (\n          Object.keys(instance.getRowModel().rowsById).some(\n            id => !instance.getIsRowExpanded(id)\n          )\n        ) {\n          return false\n        }\n\n        // They must all be expanded :shrug:\n        return true\n      },\n      getExpandedDepth: () => {\n        let maxDepth = 0\n\n        const rowIds =\n          instance.getState().expanded === true\n            ? Object.keys(instance.getRowModel().rowsById)\n            : Object.keys(instance.getState().expanded)\n\n        rowIds.forEach(id => {\n          const splitId = id.split('.')\n          maxDepth = Math.max(maxDepth, splitId.length)\n        })\n\n        return maxDepth\n      },\n      getExpandedRowModel: memo(\n        () => [\n          instance.getState().expanded,\n          instance.getGroupedRowModel(),\n          instance.options.expandRowsFn,\n          instance.options.paginateExpandedRows,\n        ],\n        (expanded, rowModel, expandRowsFn, paginateExpandedRows) => {\n          if (\n            !expandRowsFn ||\n            // Do not expand if rows are not included in pagination\n            !paginateExpandedRows ||\n            !Object.keys(expanded ?? {}).length\n          ) {\n            return rowModel\n          }\n\n          return expandRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getExpandedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => {\n            instance._notifyPageIndexReset()\n          },\n        }\n      ),\n\n      getPreExpandedRowModel: () => instance.getGroupedRowModel(),\n    }\n  },\n\n  createRow: <TGenerics extends PartialGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ExpandedRow => {\n    return {\n      toggleExpanded: expanded =>\n        void instance.toggleRowExpanded(row.id, expanded),\n      getIsExpanded: () => instance.getIsRowExpanded(row.id),\n      getCanExpand: () => row.subRows && !!row.subRows.length,\n      getToggleExpandedProps: userProps => {\n        const initialProps: ToggleExpandedProps = {\n          title: 'Toggle Row Expanded',\n          onClick: (e: MouseEvent | TouchEvent) => {\n            e.stopPropagation()\n            instance.toggleRowExpanded(row.id)\n          },\n        }\n        return propGetter(initialProps, userProps)\n      },\n    }\n  },\n}\n", "import {\n  OnChangeFn,\n  PartialGenerics,\n  TableInstance,\n  RowModel,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nexport type PaginationState = {\n  pageIndex: number\n  pageSize: number\n  pageCount: number\n}\n\nexport type PaginationTableState = {\n  pagination: PaginationState\n}\n\nexport type PaginationOptions<TGenerics extends PartialGenerics> = {\n  onPaginationChange?: OnChangeFn<PaginationState>\n  autoResetPageIndex?: boolean\n  paginateRowsFn?: (\n    instance: TableInstance<TGenerics>,\n    rowModel: RowModel<TGenerics>\n  ) => RowModel<TGenerics>\n}\n\nexport type PaginationDefaultOptions = {\n  onPaginationChange: OnChangeFn<PaginationState>\n  autoResetPageIndex: boolean\n}\n\nexport type PaginationInstance<TGenerics extends PartialGenerics> = {\n  _notifyPageIndexReset: () => void\n  setPagination: (updater: Updater<PaginationState>) => void\n  resetPagination: () => void\n  setPageIndex: (updater: Updater<number>) => void\n  resetPageIndex: () => void\n  setPageSize: (updater: Updater<number>) => void\n  resetPageSize: () => void\n  setPageCount: (updater: Updater<number>) => void\n  getPageOptions: () => number[]\n  getCanPreviousPage: () => boolean\n  getCanNextPage: () => boolean\n  previousPage: () => void\n  nextPage: () => void\n  getPrePaginationRowModel: () => RowModel<TGenerics>\n  getPaginationRowModel: () => RowModel<TGenerics>\n  getPageCount: () => number\n}\n\n//\n\nexport const Pagination = {\n  getInitialState: (): PaginationTableState => {\n    return {\n      pagination: {\n        pageCount: -1,\n        pageIndex: 0,\n        pageSize: 10,\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): PaginationDefaultOptions => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', instance),\n      autoResetPageIndex: true,\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): PaginationInstance<TGenerics> => {\n    let registered = false\n    return {\n      _notifyPageIndexReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetPageIndex\n        ) {\n          instance.resetPageIndex()\n        }\n      },\n      setPagination: updater => {\n        const safeUpdater: Updater<PaginationState> = old => {\n          let newState = functionalUpdate(updater, old)\n\n          return newState\n        }\n\n        return instance.options.onPaginationChange?.(\n          safeUpdater,\n          functionalUpdate(safeUpdater, instance.getState().pagination)\n        )\n      },\n      resetPagination: () => {\n        instance.setPagination(\n          instance.initialState.pagination ?? {\n            pageIndex: 0,\n            pageSize: 10,\n            pageCount: -1,\n          }\n        )\n      },\n      setPageIndex: updater => {\n        instance.setPagination(old => {\n          let pageIndex = functionalUpdate(updater, old.pageIndex)\n\n          const maxPageIndex =\n            old.pageCount && old.pageCount > 0\n              ? old.pageCount - 1\n              : Number.MAX_SAFE_INTEGER\n\n          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex)\n\n          return {\n            ...old,\n            pageIndex,\n          }\n        })\n      },\n      resetPageIndex: () => {\n        instance.setPageIndex(0)\n      },\n      resetPageSize: () => {\n        instance.setPageSize(instance.initialState?.pagination?.pageSize ?? 10)\n      },\n      setPageSize: updater => {\n        instance.setPagination(old => {\n          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize))\n          const topRowIndex = old.pageSize * old.pageIndex!\n          const pageIndex = Math.floor(topRowIndex / pageSize)\n\n          return {\n            ...old,\n            pageIndex,\n            pageSize,\n          }\n        })\n      },\n      setPageCount: updater =>\n        instance.setPagination(old => {\n          let newPageCount = functionalUpdate(updater, old.pageCount)\n\n          if (typeof newPageCount === 'number') {\n            newPageCount = Math.max(-1, newPageCount)\n          }\n\n          return {\n            ...old,\n            pageCount: newPageCount,\n          }\n        }),\n\n      getPageOptions: memo(\n        () => [\n          instance.getState().pagination.pageSize,\n          instance.getState().pagination.pageCount,\n        ],\n        (pageSize, pageCount) => {\n          let pageOptions: number[] = []\n          if (pageCount && pageCount > 0) {\n            pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i)\n          }\n          return pageOptions\n        },\n        {\n          key: 'getPageOptions',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getCanPreviousPage: () => instance.getState().pagination.pageIndex > 0,\n\n      getCanNextPage: () => {\n        const { pageIndex, pageCount, pageSize } =\n          instance.getState().pagination\n\n        if (pageCount === -1) {\n          return true\n        }\n\n        if (pageCount === 0) {\n          return false\n        }\n\n        return (\n          pageIndex <\n          Math.ceil(\n            instance.getPrePaginationRowModel().rows.length / pageSize\n          ) -\n            1\n        )\n      },\n\n      previousPage: () => {\n        return instance.setPageIndex(old => old - 1)\n      },\n\n      nextPage: () => {\n        return instance.setPageIndex(old => {\n          return old + 1\n        })\n      },\n\n      getPrePaginationRowModel: () => instance.getExpandedRowModel(),\n      getPaginationRowModel: memo(\n        () => [\n          instance.getState().pagination,\n          instance.getExpandedRowModel(),\n          instance.options.paginateRowsFn,\n        ],\n        (_pagination, rowModel, paginateRowsFn) => {\n          if (!paginateRowsFn || !rowModel.rows.length) {\n            return rowModel\n          }\n\n          return paginateRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getPaginationRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getPageCount: () => {\n        const { pageCount } = instance.getState().pagination\n        if (pageCount > 0) {\n          return pageCount\n        }\n\n        return Math.ceil(\n          instance.getPrePaginationRowModel().rows.length /\n            instance.getState().pagination.pageSize\n        )\n      },\n    }\n  },\n}\n", "import React, { MouseEvent, TouchEvent } from 'react'\nimport {\n  Getter,\n  OnChangeFn,\n  PartialGenerics,\n  PropGetterValue,\n  TableInstance,\n  Row,\n  RowModel,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type RowSelectionState = Record<string, boolean>\n\nexport type RowSelectionTableState = {\n  rowSelection: RowSelectionState\n}\n\nexport type RowSelectionOptions<TGenerics extends PartialGenerics> = {\n  onRowSelectionChange?: OnChangeFn<RowSelectionState>\n  autoResetRowSelection?: boolean\n  enableRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  enableMultiRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  enableSubRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  // enableGroupingRowSelection?:\n  //   | boolean\n  //   | ((\n  //       row: Row<TGenerics>\n  //     ) => boolean)\n  // isAdditiveSelectEvent?: (e: MouseEvent | TouchEvent) => boolean\n  // isInclusiveSelectEvent?: (e: MouseEvent | TouchEvent) => boolean\n  // selectRowsFn?: (\n  //   instance: TableInstance<\n  //     TData,\n  //     TValue,\n  //     TFilterFns,\n  //     TSortingFns,\n  //     TAggregationFns\n  //   >,\n  //   rowModel: RowModel<TGenerics>\n  // ) => RowModel<TGenerics>\n}\n\ntype ToggleRowSelectedProps = {\n  onChange?: (e: MouseEvent | TouchEvent) => void\n  checked?: boolean\n  title?: string\n  indeterminate?: boolean\n}\n\nexport type RowSelectionRow = {\n  getIsSelected: () => boolean\n  getIsSomeSelected: () => boolean\n  getCanSelect: () => boolean\n  getCanMultiSelect: () => boolean\n  toggleSelected: (value?: boolean) => void\n  getToggleSelectedProps: <TGetter extends Getter<ToggleRowSelectedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n}\n\nexport type RowSelectionInstance<TGenerics extends PartialGenerics> = {\n  _notifyRowSelectionReset: () => void\n  getToggleRowSelectedProps: <TGetter extends Getter<ToggleRowSelectedProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n  getToggleAllRowsSelectedProps: <\n    TGetter extends Getter<ToggleRowSelectedProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n  getToggleAllPageRowsSelectedProps: <\n    TGetter extends Getter<ToggleRowSelectedProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleRowSelectedProps, TGetter>\n  setRowSelection: (updater: Updater<RowSelectionState>) => void\n  resetRowSelection: () => void\n  toggleRowSelected: (rowId: string, value?: boolean) => void\n  getRowCanSelect: (rowId: string) => boolean\n  getRowCanSelectSubRows: (rowId: string) => boolean\n  getRowCanMultiSelect: (rowId: string) => boolean\n  // getGroupingRowCanSelect: (rowId: string) => boolean\n  getRowIsSelected: (rowId: string) => boolean\n  getRowIsSomeSelected: (rowId: string) => boolean\n  getIsAllRowsSelected: () => boolean\n  getIsAllPageRowsSelected: () => boolean\n  getIsSomeRowsSelected: () => boolean\n  getIsSomePageRowsSelected: () => boolean\n  toggleAllRowsSelected: (value: boolean) => void\n  toggleAllPageRowsSelected: (value: boolean) => void\n  getPreSelectedRowModel: () => RowModel<TGenerics>\n  getSelectedRowModel: () => RowModel<TGenerics>\n  getFilteredSelectedRowModel: () => RowModel<TGenerics>\n  getGroupedSelectedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const RowSelection = {\n  getInitialState: (): RowSelectionTableState => {\n    return {\n      rowSelection: {},\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowSelectionOptions<TGenerics> => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', instance),\n      autoResetRowSelection: true,\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true,\n      // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: MouseEvent | TouchEvent) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: MouseEvent | TouchEvent) => !!e.shiftKey,\n    }\n  },\n\n  getInstance: <TGenerics extends PartialGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowSelectionInstance<TGenerics> => {\n    let registered = false\n\n    // const pageRows = instance.getPageRows()\n\n    return {\n      _notifyRowSelectionReset: () => {\n        if (!registered) {\n          registered = true\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetRowSelection\n        ) {\n          instance.resetRowSelection()\n        }\n      },\n      setRowSelection: updater =>\n        instance.options.onRowSelectionChange?.(\n          updater,\n          functionalUpdate(updater, instance.getState().rowSelection)\n        ),\n      resetRowSelection: () =>\n        instance.setRowSelection(instance.initialState.rowSelection ?? {}),\n      toggleAllRowsSelected: value => {\n        instance.setRowSelection(old => {\n          value =\n            typeof value !== 'undefined'\n              ? value\n              : !instance.getIsAllRowsSelected()\n\n          // Only remove/add the rows that are visible on the screen\n          //  Leave all the other rows that are selected alone.\n          const rowSelection = Object.assign({}, old)\n\n          const preGroupedFlatRows = instance.getPreGroupedRowModel().flatRows\n\n          // We don't use `mutateRowIsSelected` here for performance reasons.\n          // All of the rows are flat already, so it wouldn't be worth it\n          if (value) {\n            preGroupedFlatRows.forEach(row => {\n              rowSelection[row.id] = true\n            })\n          } else {\n            preGroupedFlatRows.forEach(row => {\n              delete rowSelection[row.id]\n            })\n          }\n\n          return rowSelection\n        })\n      },\n      toggleAllPageRowsSelected: value =>\n        instance.setRowSelection(old => {\n          const selectAll =\n            typeof value !== 'undefined'\n              ? value\n              : !instance.getIsAllPageRowsSelected()\n\n          const rowSelection: RowSelectionState = { ...old }\n\n          instance.getRowModel().rows.forEach(row => {\n            mutateRowIsSelected(rowSelection, row.id, value, instance)\n          })\n\n          return rowSelection\n        }),\n      toggleRowSelected: (rowId, value) => {\n        const row = instance.getRow(rowId)\n        const isSelected = row.getIsSelected()\n\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !isSelected\n\n          if (isSelected === value) {\n            return old\n          }\n\n          const selectedRowIds = { ...old }\n\n          mutateRowIsSelected(selectedRowIds, rowId, value, instance)\n\n          return selectedRowIds\n        })\n      },\n      // addRowSelectionRange: rowId => {\n      //   const {\n      //     rows,\n      //     rowsById,\n      //     options: { selectGroupingRows, selectSubRows },\n      //   } = instance\n\n      //   const findSelectedRow = (rows: Row[]) => {\n      //     let found\n      //     rows.find(d => {\n      //       if (d.getIsSelected()) {\n      //         found = d\n      //         return true\n      //       }\n      //       const subFound = findSelectedRow(d.subRows || [])\n      //       if (subFound) {\n      //         found = subFound\n      //         return true\n      //       }\n      //       return false\n      //     })\n      //     return found\n      //   }\n\n      //   const firstRow = findSelectedRow(rows) || rows[0]\n      //   const lastRow = rowsById[rowId]\n\n      //   let include = false\n      //   const selectedRowIds = {}\n\n      //   const addRow = (row: Row) => {\n      //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n      //       rowsById,\n      //       selectGroupingRows: selectGroupingRows!,\n      //       selectSubRows: selectSubRows!,\n      //     })\n      //   }\n\n      //   instance.rows.forEach(row => {\n      //     const isFirstRow = row.id === firstRow.id\n      //     const isLastRow = row.id === lastRow.id\n\n      //     if (isFirstRow || isLastRow) {\n      //       if (!include) {\n      //         include = true\n      //       } else if (include) {\n      //         addRow(row)\n      //         include = false\n      //       }\n      //     }\n\n      //     if (include) {\n      //       addRow(row)\n      //     }\n      //   })\n\n      //   instance.setRowSelection(selectedRowIds)\n      // },\n      getPreSelectedRowModel: () => instance.getCoreRowModel(),\n      getSelectedRowModel: memo(\n        () => [instance.getState().rowSelection, instance.getCoreRowModel()],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n\n      getFilteredSelectedRowModel: memo(\n        () => [\n          instance.getState().rowSelection,\n          instance.getGlobalFilteredRowModel(),\n        ],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getFilteredSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n\n      getGroupedSelectedRowModel: memo(\n        () => [instance.getState().rowSelection, instance.getGroupedRowModel()],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: 'getGroupedSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n          onChange: () => instance._notifyExpandedReset(),\n        }\n      ),\n\n      ///\n\n      getRowIsSelected: rowId => {\n        const { rowSelection } = instance.getState()\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        return isRowSelected(row, rowSelection, instance) === true\n      },\n\n      getRowIsSomeSelected: rowId => {\n        const { rowSelection } = instance.getState()\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        return isRowSelected(row, rowSelection, instance) === 'some'\n      },\n\n      getRowCanSelect: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        if (typeof instance.options.enableRowSelection === 'function') {\n          return instance.options.enableRowSelection(row)\n        }\n\n        return instance.options.enableRowSelection ?? true\n      },\n\n      getRowCanSelectSubRows: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        if (typeof instance.options.enableSubRowSelection === 'function') {\n          return instance.options.enableSubRowSelection(row)\n        }\n\n        return instance.options.enableSubRowSelection ?? true\n      },\n\n      getRowCanMultiSelect: rowId => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          throw new Error()\n        }\n\n        if (typeof instance.options.enableMultiRowSelection === 'function') {\n          return instance.options.enableMultiRowSelection(row)\n        }\n\n        return instance.options.enableMultiRowSelection ?? true\n      },\n\n      // getGroupingRowCanSelect: rowId => {\n      //   const row = instance.getRow(rowId)\n\n      //   if (!row) {\n      //     throw new Error()\n      //   }\n\n      //   if (typeof instance.options.enableGroupingRowSelection === 'function') {\n      //     return instance.options.enableGroupingRowSelection(row)\n      //   }\n\n      //   return instance.options.enableGroupingRowSelection ?? false\n      // },\n\n      getIsAllRowsSelected: () => {\n        const preFilteredFlatRows =\n          instance.getPreGlobalFilteredRowModel().flatRows\n        const { rowSelection } = instance.getState()\n\n        let isAllRowsSelected = Boolean(\n          preFilteredFlatRows.length && Object.keys(rowSelection).length\n        )\n\n        if (isAllRowsSelected) {\n          if (preFilteredFlatRows.some(row => !rowSelection[row.id])) {\n            isAllRowsSelected = false\n          }\n        }\n\n        return isAllRowsSelected\n      },\n\n      getIsAllPageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows\n        const { rowSelection } = instance.getState()\n\n        let isAllPageRowsSelected = !!paginationFlatRows.length\n\n        if (\n          isAllPageRowsSelected &&\n          paginationFlatRows.some(row => !rowSelection[row.id])\n        ) {\n          isAllPageRowsSelected = false\n        }\n\n        return isAllPageRowsSelected\n      },\n\n      getIsSomeRowsSelected: () => {\n        return (\n          !instance.getIsAllRowsSelected() &&\n          !!Object.keys(instance.getState().rowSelection ?? {}).length\n        )\n      },\n\n      getIsSomePageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows\n        return instance.getIsAllPageRowsSelected()\n          ? false\n          : !!paginationFlatRows?.length\n      },\n\n      getToggleRowSelectedProps: (rowId, userProps) => {\n        const row = instance.getRow(rowId)\n\n        const isSelected = row.getIsSelected()\n        const isSomeSelected = row.getIsSomeSelected()\n        const canSelect = row.getCanSelect()\n\n        const initialProps: ToggleRowSelectedProps = {\n          onChange: canSelect\n            ? (e: MouseEvent | TouchEvent) => {\n                row.toggleSelected((e.target as HTMLInputElement).checked)\n              }\n            : undefined,\n          checked: isSelected,\n          title: 'Toggle Row Selected',\n          indeterminate: isSomeSelected,\n          // onChange: forInput\n          //   ? (e: Event) => e.stopPropagation()\n          //   : (e: Event) => {\n          //       if (instance.options.isAdditiveSelectEvent(e)) {\n          //         row.toggleSelected()\n          //       } else if (instance.options.isInclusiveSelectEvent(e)) {\n          //         instance.addRowSelectionRange(row.id)\n          //       } else {\n          //         instance.setRowSelection({})\n          //         row.toggleSelected()\n          //       }\n\n          //       if (props.onClick) props.onClick(e)\n          //     },\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getToggleAllRowsSelectedProps: userProps => {\n        const isSomeRowsSelected = instance.getIsSomeRowsSelected()\n        const isAllRowsSelected = instance.getIsAllRowsSelected()\n\n        const initialProps: ToggleRowSelectedProps = {\n          onChange: (e: MouseEvent | TouchEvent) => {\n            instance.toggleAllRowsSelected(\n              (e.target as HTMLInputElement).checked\n            )\n          },\n          checked: isAllRowsSelected,\n          title: 'Toggle All Rows Selected',\n          indeterminate: isSomeRowsSelected,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n\n      getToggleAllPageRowsSelectedProps: userProps => {\n        const isSomePageRowsSelected = instance.getIsSomePageRowsSelected()\n        const isAllPageRowsSelected = instance.getIsAllPageRowsSelected()\n\n        const initialProps: ToggleRowSelectedProps = {\n          onChange: (e: MouseEvent | TouchEvent) => {\n            instance.toggleAllPageRowsSelected(\n              (e.target as HTMLInputElement).checked\n            )\n          },\n          checked: isAllPageRowsSelected,\n          title: 'Toggle All Current Page Rows Selected',\n          indeterminate: isSomePageRowsSelected,\n        }\n\n        return propGetter(initialProps, userProps)\n      },\n    }\n  },\n\n  createRow: <TGenerics extends PartialGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): RowSelectionRow => {\n    return {\n      getIsSelected: () => instance.getRowIsSelected(row.id),\n      getIsSomeSelected: () => instance.getRowIsSomeSelected(row.id),\n      toggleSelected: value => instance.toggleRowSelected(row.id, value),\n      getToggleSelectedProps: userProps =>\n        instance.getToggleRowSelectedProps(row.id, userProps),\n      getCanMultiSelect: () => instance.getRowCanMultiSelect(row.id),\n      getCanSelect: () => instance.getRowCanSelect(row.id),\n    }\n  },\n}\n\nconst mutateRowIsSelected = <TGenerics extends PartialGenerics>(\n  selectedRowIds: Record<string, boolean>,\n  id: string,\n  value: boolean,\n  instance: TableInstance<TGenerics>\n) => {\n  const row = instance.getRow(id)\n\n  const isGrouped = row.getIsGrouped()\n\n  // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && instance.options.enableGroupingRowSelection)\n  // ) {\n  if (value) {\n    selectedRowIds[id] = true\n  } else {\n    delete selectedRowIds[id]\n  }\n  // }\n\n  if (row.subRows?.length && instance.getRowCanSelectSubRows(row.id)) {\n    row.subRows.forEach(row =>\n      mutateRowIsSelected(selectedRowIds, row.id, value, instance)\n    )\n  }\n}\n\nexport function selectRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const rowSelection = instance.getState().rowSelection\n\n  const newSelectedFlatRows: Row<TGenerics>[] = []\n  const newSelectedRowsById: Record<string, Row<TGenerics>> = {}\n\n  // Filters top level and nested rows\n  const recurseRows = (rows: Row<TGenerics>[], depth = 0) => {\n    return rows\n      .map(row => {\n        const isSelected = isRowSelected(row, rowSelection, instance) === true\n\n        if (isSelected) {\n          newSelectedFlatRows.push(row)\n          newSelectedRowsById[row.id] = row\n        }\n\n        if (row.subRows?.length) {\n          row = {\n            ...row,\n            subRows: recurseRows(row.subRows, depth + 1),\n          }\n        }\n\n        if (isSelected) {\n          return row\n        }\n      })\n      .filter(Boolean) as Row<TGenerics>[]\n  }\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById,\n  }\n}\n\nexport function isRowSelected<TGenerics extends PartialGenerics>(\n  row: Row<TGenerics>,\n  selection: Record<string, boolean>,\n  instance: TableInstance<TGenerics>\n): boolean | 'some' {\n  if (selection[row.id]) {\n    return true\n  }\n\n  if (row.subRows && row.subRows.length) {\n    let allChildrenSelected = true\n    let someSelected = false\n\n    row.subRows.forEach(subRow => {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return\n      }\n\n      if (isRowSelected(subRow, selection, instance)) {\n        someSelected = true\n      } else {\n        allChildrenSelected = false\n      }\n    })\n\n    return allChildrenSelected ? true : someSelected ? 'some' : false\n  }\n\n  return false\n}\n", "import {\n  flattenBy,\n  functionalUpdate,\n  propGetter,\n  memo,\n  flexRender,\n  RequiredKeys,\n} from './utils'\n\nimport {\n  Updater,\n  PropGetterValue,\n  Options,\n  TableState,\n  ColumnDef,\n  Row,\n  Column,\n  Cell,\n  Header,\n  AccessorFn,\n  HeaderRenderProps,\n  TableProps,\n  TableBodyProps,\n  PropGetter,\n  Getter,\n  RowProps,\n  CellProps,\n  TableInstance,\n  RowValues,\n  Renderable,\n  Please_use_the_create_table_column_utilities_to_define_columns,\n  PartialGenerics,\n} from './types'\n\nimport { Visibility } from './features/Visibility'\nimport { Ordering } from './features/Ordering'\nimport { Pinning } from './features/Pinning'\nimport { Headers } from './features/Headers'\nimport { Filters } from './features/Filters'\nimport { Sorting } from './features/Sorting'\nimport { Grouping, GroupingCell } from './features/Grouping'\nimport { Expanding } from './features/Expanding'\nimport { ColumnSizing, defaultColumnSizing } from './features/ColumnSizing'\nimport { Pagination } from './features/Pagination'\nimport { RowSelection } from './features/RowSelection'\nimport { RowModel } from '.'\n\nconst features = [\n  Visibility,\n  Ordering,\n  Pinning,\n  Headers,\n  Filters,\n  Sorting,\n  Grouping,\n  Expanding,\n  ColumnSizing,\n  Pagination,\n  RowSelection,\n]\n\nexport type CoreOptions<TGenerics extends PartialGenerics> = {\n  data: TGenerics['Row'][]\n  columns: ColumnDef<TGenerics>[]\n  state: Partial<TableState>\n  onStateChange: (updater: Updater<TableState>) => void\n  debugAll?: boolean\n  debugTable?: boolean\n  debugHeaders?: boolean\n  debugColumns?: boolean\n  debugRows?: boolean\n  defaultColumn?: Partial<ColumnDef<TGenerics>>\n  initialState?: Partial<TableState>\n  getSubRows?: (\n    originalRow: TGenerics['Row'],\n    index: number\n  ) => TGenerics['Row'][]\n  getRowId?: (\n    originalRow: TGenerics['Row'],\n    index: number,\n    parent?: Row<TGenerics>\n  ) => string\n  autoResetAll?: boolean\n}\n\nexport type TableCore<TGenerics extends PartialGenerics> = {\n  initialState: TableState\n  reset: () => void\n  options: RequiredKeys<Options<TGenerics>, 'state'>\n  setOptions: (newOptions: Updater<Options<TGenerics>>) => void\n  getRowId: (\n    _: TGenerics['Row'],\n    index: number,\n    parent?: Row<TGenerics>\n  ) => string\n  getState: () => TableState\n  setState: (updater: Updater<TableState>) => void\n  getDefaultColumn: () => Partial<ColumnDef<TGenerics>>\n  getColumnDefs: () => ColumnDef<TGenerics>[]\n  createColumn: (\n    columnDef: ColumnDef<TGenerics>,\n    depth: number,\n    parent?: Column<TGenerics>\n  ) => Column<TGenerics>\n  getAllColumns: () => Column<TGenerics>[]\n  getAllFlatColumns: () => Column<TGenerics>[]\n  getAllFlatColumnsById: () => Record<string, Column<TGenerics>>\n  getAllLeafColumns: () => Column<TGenerics>[]\n  getColumn: (columnId: string) => Column<TGenerics>\n  getColumnWidth: (columnId: string) => number\n  getTotalWidth: () => number\n  createCell: (\n    row: Row<TGenerics>,\n    column: Column<TGenerics>,\n    value: any\n  ) => Cell<TGenerics>\n  createRow: (\n    id: string,\n    original: TGenerics['Row'] | undefined,\n    rowIndex: number,\n    depth: number,\n    values: Record<string, any>\n  ) => Row<TGenerics>\n  getCoreRowModel: () => RowModel<TGenerics>\n  getRowModel: () => RowModel<TGenerics>\n  getRow: (id: string) => Row<TGenerics>\n  getCell: (rowId: string, columnId: string) => Cell<TGenerics>\n  getTableProps: PropGetter<TableProps>\n  getTableBodyProps: PropGetter<TableBodyProps>\n  getRowProps: <TGetter extends Getter<RowProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<RowProps, TGetter>\n  getCellProps: <TGetter extends Getter<CellProps>>(\n    rowId: string,\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<CellProps, TGetter>\n  getTableWidth: () => number\n  getLeftTableWidth: () => number\n  getCenterTableWidth: () => number\n  getRightTableWidth: () => number\n}\n\nexport type CoreRow<TGenerics extends PartialGenerics> = {\n  id: string\n  index: number\n  original?: TGenerics['Row']\n  depth: number\n  values: RowValues\n  leafRows: Row<TGenerics>[]\n  subRows: Row<TGenerics>[]\n  getRowProps: PropGetter<RowProps>\n  originalSubRows?: TGenerics['Row'][]\n  getAllCells: () => Cell<TGenerics>[]\n  getAllCellsByColumnId: () => Record<string, Cell<TGenerics>>\n}\n\nexport type CoreColumnDef<TGenerics extends PartialGenerics> = {\n  id: string\n  accessorKey?: string & keyof TGenerics['Row']\n  accessorFn?: AccessorFn<TGenerics['Row']>\n  header?:\n    | string\n    | Renderable<{\n        instance: TableInstance<TGenerics>\n        header: Header<TGenerics>\n        column: Column<TGenerics>\n      }>\n  width?: number\n  minWidth?: number\n  maxWidth?: number\n  columns?: ColumnDef<TGenerics>[]\n  footer?: Renderable<{\n    instance: TableInstance<TGenerics>\n    header: Header<TGenerics>\n    column: Column<TGenerics>\n  }>\n  cell?: Renderable<{\n    instance: TableInstance<TGenerics>\n    row: Row<TGenerics>\n    column: Column<TGenerics>\n    cell: Cell<TGenerics>\n    value: TGenerics['Value']\n  }>\n  defaultIsVisible?: boolean\n  [Please_use_the_create_table_column_utilities_to_define_columns]: true\n}\n\nexport type CoreColumn<TGenerics extends PartialGenerics> = {\n  id: string\n  depth: number\n  accessorFn?: AccessorFn<TGenerics['Row']>\n  columnDef: ColumnDef<TGenerics>\n  getWidth: () => number\n  columns: Column<TGenerics>[]\n  parent?: Column<TGenerics>\n  getFlatColumns: () => Column<TGenerics>[]\n  getLeafColumns: () => Column<TGenerics>[]\n}\n\nexport function createTableInstance<TGenerics extends PartialGenerics>(\n  options: Options<TGenerics>\n): TableInstance<TGenerics> {\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating React Table Instance...')\n  }\n\n  let instance = {} as TableInstance<TGenerics>\n\n  let listeners: (() => void)[] = []\n\n  const defaultOptions = features.reduce((obj, feature) => {\n    return Object.assign(obj, (feature as any).getDefaultOptions?.(instance))\n  }, {})\n\n  const buildOptions = (options: Options<TGenerics>) => ({\n    ...defaultOptions,\n    ...options,\n  })\n\n  instance.options = buildOptions(options)\n\n  const initialState = {\n    ...features.reduce((obj, feature) => {\n      return Object.assign(obj, (feature as any).getInitialState?.())\n    }, {}),\n    ...(options.initialState ?? {}),\n  } as TableState\n\n  const finalInstance: TableInstance<TGenerics> = {\n    ...instance,\n    ...features.reduce((obj, feature) => {\n      return Object.assign(obj, (feature as any).getInstance?.(instance))\n    }, {}),\n    initialState,\n    reset: () => {\n      instance.setState(instance.initialState)\n    },\n    setOptions: updater => {\n      instance.options = buildOptions(\n        functionalUpdate(updater, instance.options)\n      )\n    },\n\n    getRowId: (_: TGenerics['Row'], index: number, parent?: Row<TGenerics>) =>\n      `${parent ? [parent.id, index].join('.') : index}`,\n\n    getState: () => {\n      return instance.options.state as TableState\n    },\n\n    setState: (updater: Updater<TableState>) => {\n      instance.options.onStateChange?.(updater)\n    },\n\n    getDefaultColumn: memo(\n      () => [instance.options.defaultColumn],\n      defaultColumn => {\n        defaultColumn = (defaultColumn ?? {}) as Partial<ColumnDef<TGenerics>>\n\n        return {\n          header: (props: HeaderRenderProps<Header<TGenerics>>) =>\n            props.header.column.id,\n          footer: (props: HeaderRenderProps<Header<TGenerics>>) =>\n            props.header.column.id,\n          cell: ({ value = '' }: { value: any }): JSX.Element =>\n            typeof value === 'boolean' ? value.toString() : value,\n          ...features.reduce((obj, feature) => {\n            return Object.assign(obj, (feature as any).getDefaultColumn?.())\n          }, {}),\n          ...defaultColumn,\n        } as Partial<ColumnDef<TGenerics>>\n      },\n      {\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n        key: 'getDefaultColumn',\n      }\n    ),\n\n    getColumnDefs: () => instance.options.columns,\n\n    createColumn: (columnDef, depth: number, parent) => {\n      const defaultColumn = instance.getDefaultColumn()\n\n      let id =\n        columnDef.id ??\n        columnDef.accessorKey ??\n        (typeof columnDef.header === 'string' ? columnDef.header : undefined)\n\n      let accessorFn: AccessorFn<TGenerics['Row']> | undefined\n\n      if (columnDef.accessorFn) {\n        accessorFn = columnDef.accessorFn\n      } else if (columnDef.accessorKey) {\n        accessorFn = (originalRow?: TGenerics['Row']) =>\n          (originalRow as any)[columnDef.accessorKey]\n      }\n\n      if (!id) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            columnDef.accessorFn\n              ? `Columns require an id when using an accessorFn`\n              : `Columns require an id when using a non-string header`\n          )\n        }\n        throw new Error()\n      }\n\n      let column: CoreColumn<TGenerics> = {\n        ...defaultColumnSizing,\n        ...defaultColumn,\n        ...columnDef,\n        id: `${id}`,\n        accessorFn,\n        parent: parent as any,\n        depth,\n        columnDef,\n        columns: [],\n        getWidth: () => instance.getColumnWidth(column.id),\n        getFlatColumns: memo(\n          () => [true],\n          () => {\n            return [\n              column as Column<TGenerics>,\n              ...column.columns?.flatMap(d => d.getFlatColumns()),\n            ]\n          },\n          {\n            key: 'column.getFlatColumns',\n            debug: () =>\n              instance.options.debugAll ?? instance.options.debugColumns,\n          }\n        ),\n        getLeafColumns: memo(\n          () => [instance.getOrderColumnsFn()],\n          orderColumns => {\n            if (column.columns?.length) {\n              let leafColumns = column.columns.flatMap(column =>\n                column.getLeafColumns()\n              )\n\n              return orderColumns(leafColumns)\n            }\n\n            return [column as Column<TGenerics>]\n          },\n          {\n            key: 'column.getLeafColumns',\n            debug: () =>\n              instance.options.debugAll ?? instance.options.debugColumns,\n          }\n        ),\n      }\n\n      column = features.reduce((obj, feature) => {\n        return Object.assign(\n          obj,\n          (feature as any).createColumn?.(column, instance)\n        )\n      }, column)\n\n      // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n      return column as Column<TGenerics>\n    },\n\n    getAllColumns: memo(\n      () => [instance.getColumnDefs()],\n      columnDefs => {\n        const recurseColumns = (\n          columnDefs: ColumnDef<TGenerics>[],\n          parent?: Column<TGenerics>,\n          depth = 0\n        ): Column<TGenerics>[] => {\n          return columnDefs.map(columnDef => {\n            const column = instance.createColumn(columnDef, depth, parent)\n\n            column.columns = columnDef.columns\n              ? recurseColumns(columnDef.columns, column, depth + 1)\n              : []\n\n            return column\n          })\n        }\n\n        return recurseColumns(columnDefs)\n      },\n      {\n        key: 'getAllColumns',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getAllFlatColumns: memo(\n      () => [instance.getAllColumns()],\n      allColumns => {\n        return allColumns.flatMap(column => {\n          return column.getFlatColumns()\n        })\n      },\n      {\n        key: 'getAllFlatColumns',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getAllFlatColumnsById: memo(\n      () => [instance.getAllFlatColumns()],\n      flatColumns => {\n        return flatColumns.reduce((acc, column) => {\n          acc[column.id] = column\n          return acc\n        }, {} as Record<string, Column<TGenerics>>)\n      },\n      {\n        key: 'getAllFlatColumnsById',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getAllLeafColumns: memo(\n      () => [instance.getAllColumns(), instance.getOrderColumnsFn()],\n      (allColumns, orderColumns) => {\n        let leafColumns = allColumns.flatMap(column => column.getLeafColumns())\n        return orderColumns(leafColumns)\n      },\n      {\n        key: 'getAllLeafColumns',\n        debug: () => instance.options.debugAll ?? instance.options.debugColumns,\n      }\n    ),\n\n    getColumn: columnId => {\n      const column = instance.getAllFlatColumnsById()[columnId]\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `[React Table] Column with id ${columnId} does not exist.`\n          )\n        }\n        throw new Error()\n      }\n\n      return column\n    },\n\n    getColumnWidth: (columnId: string) => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      const columnSize = instance.getState().columnSizing[column.id]\n\n      return Math.min(\n        Math.max(\n          column.minWidth ?? defaultColumnSizing.minWidth,\n          columnSize ?? column.width ?? defaultColumnSizing.width\n        ),\n        column.maxWidth ?? defaultColumnSizing.maxWidth\n      )\n    },\n\n    createCell: (row, column, value) => {\n      const cell: Cell<TGenerics> = {\n        id: `${row.id}_${column.id}`,\n        rowId: row.id,\n        columnId: column.id,\n        row,\n        column,\n        value,\n        getCellProps: userProps =>\n          instance.getCellProps(row.id, column.id, userProps)!,\n        renderCell: () =>\n          flexRender(column.cell, { instance, column, row, cell, value }),\n      }\n\n      features.forEach(feature => {\n        Object.assign(\n          cell,\n          (feature as any).createCell?.(\n            cell as Cell<TGenerics> & GroupingCell,\n            column,\n            row as Row<TGenerics>,\n            instance\n          )\n        )\n      }, {})\n\n      return cell\n    },\n\n    createRow: (id, original, rowIndex, depth, values) => {\n      let row: CoreRow<TGenerics> = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        values,\n        subRows: [],\n        leafRows: [],\n        getRowProps: userProps => instance.getRowProps(row.id, userProps)!,\n        getAllCells: undefined!,\n        getAllCellsByColumnId: undefined!,\n      }\n\n      row.getAllCells = memo(\n        () => [instance.getAllLeafColumns()],\n        leafColumns => {\n          return leafColumns.map(column => {\n            return instance.createCell(\n              row as Row<TGenerics>,\n              column,\n              row.values[column.id]\n            )\n          })\n        },\n        {\n          key: process.env.NODE_ENV !== 'production' ? 'row.getAllCells' : '',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      )\n\n      row.getAllCellsByColumnId = memo(\n        () => [row.getAllCells()],\n        allCells => {\n          return allCells.reduce((acc, cell) => {\n            acc[cell.columnId] = cell\n            return acc\n          }, {} as Record<string, Cell<TGenerics>>)\n        },\n        {\n          key: 'row.getAllCellsByColumnId',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      )\n\n      for (let i = 0; i < features.length; i++) {\n        const feature = features[i]\n        Object.assign(row, (feature as any).createRow?.(row, instance))\n      }\n\n      return row as Row<TGenerics>\n    },\n\n    getCoreRowModel: memo(\n      () => [instance.options.data],\n      (\n        data\n      ): {\n        rows: Row<TGenerics>[]\n        flatRows: Row<TGenerics>[]\n        rowsById: Record<string, Row<TGenerics>>\n      } => {\n        // Access the row model using initial columns\n        const rows: Row<TGenerics>[] = []\n        const flatRows: Row<TGenerics>[] = []\n        const rowsById: Record<string, Row<TGenerics>> = {}\n\n        const leafColumns = instance.getAllLeafColumns()\n\n        const accessRow = (\n          originalRow: TGenerics['Row'],\n          rowIndex: number,\n          depth = 0,\n          parentRows: Row<TGenerics>[],\n          parent?: Row<TGenerics>\n        ) => {\n          const id = instance.getRowId(originalRow, rowIndex, parent)\n\n          if (!id) {\n            if (process.env.NODE_ENV !== 'production') {\n              throw new Error(`getRowId expected an ID, but got ${id}`)\n            }\n          }\n\n          const values: Record<string, any> = {}\n\n          for (let i = 0; i < leafColumns.length; i++) {\n            const column = leafColumns[i]\n            if (column && column.accessorFn) {\n              values[column.id] = column.accessorFn(originalRow, rowIndex)\n            }\n          }\n\n          // Make the row\n          const row = instance.createRow(\n            id,\n            originalRow,\n            rowIndex,\n            depth,\n            values\n          )\n\n          // Push instance row into the parentRows array\n          parentRows.push(row)\n          // Keep track of every row in a flat array\n          flatRows.push(row)\n          // Also keep track of every row by its ID\n          rowsById[id] = row\n\n          // Get the original subrows\n          if (instance.options.getSubRows) {\n            const originalSubRows = instance.options.getSubRows(\n              originalRow,\n              rowIndex\n            )\n\n            // Then recursively access them\n            if (originalSubRows?.length) {\n              row.originalSubRows = originalSubRows\n              const subRows: Row<TGenerics>[] = []\n\n              for (let i = 0; i < row.originalSubRows.length; i++) {\n                accessRow(\n                  row.originalSubRows[i] as TGenerics['Row'],\n                  i,\n                  depth + 1,\n                  subRows,\n                  row\n                )\n              }\n              // Keep the new subRows array on the row\n              row.subRows = subRows\n              row.leafRows = flattenBy(subRows, d => d.leafRows)\n            }\n          }\n        }\n\n        for (let i = 0; i < data.length; i++) {\n          accessRow(data[i] as TGenerics['Row'], i, 0, rows)\n        }\n\n        return { rows, flatRows, rowsById }\n      },\n      {\n        key: 'getRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {\n          instance._notifyRowSelectionReset()\n          instance._notifyFiltersReset()\n        },\n      }\n    ),\n\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n\n    getRowModel: () => {\n      return instance.getPaginationRowModel()\n    },\n\n    getRow: (id: string) => {\n      const row = instance.getRowModel().rowsById[id]\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(`getRow expected an ID, but got ${id}`)\n        }\n        throw new Error()\n      }\n\n      return row\n    },\n\n    getCell: (rowId: string, columnId: string) => {\n      const row = instance.getRow(rowId)\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(`[React Table] could not find row with id ${rowId}`)\n        }\n        throw new Error()\n      }\n\n      const cell = row.getAllCellsByColumnId()[columnId]\n\n      if (!cell) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `[React Table] could not find cell ${columnId} in row ${rowId}`\n          )\n        }\n        throw new Error()\n      }\n\n      return cell\n    },\n\n    getTableProps: userProps => {\n      return propGetter(\n        {\n          role: 'table',\n        },\n        userProps\n      )\n    },\n\n    getTableBodyProps: userProps => {\n      return propGetter(\n        {\n          role: 'rowgroup',\n        },\n        userProps\n      )\n    },\n\n    getRowProps: (rowId, userProps) => {\n      const row = instance.getRow(rowId)\n      if (!row) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: row.id,\n          role: 'row',\n        },\n        userProps\n      )\n    },\n\n    getCellProps: (rowId, columnId, userProps) => {\n      const cell = instance.getCell(rowId, columnId)\n\n      if (!cell) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: cell.id,\n          role: 'gridcell',\n        },\n        userProps\n      )\n    },\n\n    getTableWidth: () =>\n      instance.getHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n    getLeftTableWidth: () =>\n      instance.getLeftHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n    getCenterTableWidth: () =>\n      instance.getCenterHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n    getRightTableWidth: () =>\n      instance.getRightHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getWidth()\n      }, 0) ?? 0,\n  }\n\n  instance = Object.assign(instance, finalInstance)\n\n  return instance\n}\n", "import { CustomFilterTypes } from './features/Filters'\nimport { CustomAggregationTypes } from './features/Grouping'\nimport { CustomSortingTypes } from './features/Sorting'\nimport {\n  ColumnDef,\n  AccessorFn,\n  DefaultGenerics,\n  PartialGenerics,\n  _NonGenerated,\n} from './types'\nimport { Overwrite, PartialKeys } from './utils'\n\nexport type CreatTableFactory<TGenerics extends Partial<DefaultGenerics>> = <\n  TRow\n>() => TableFactory<Overwrite<TGenerics, { Row: TRow }>>\n\nexport type CreateTableFactoryOptions<\n  TFilterFns extends CustomFilterTypes<any>,\n  TSortingFns extends CustomSortingTypes<any>,\n  TAggregationFns extends CustomAggregationTypes<any>\n> = {\n  filterFns?: TFilterFns\n  sortingFns?: TSortingFns\n  aggregationFns?: TAggregationFns\n}\n\nexport function createTableFactory<\n  TFilterFns extends CustomFilterTypes<any>,\n  TSortingFns extends CustomSortingTypes<any>,\n  TAggregationFns extends CustomAggregationTypes<any>\n>(\n  opts: CreateTableFactoryOptions<TFilterFns, TSortingFns, TAggregationFns>\n): CreatTableFactory<\n  Overwrite<\n    PartialGenerics,\n    {\n      FilterFns: TFilterFns\n      SortingFns: TSortingFns\n      AggregationFns: TAggregationFns\n    }\n  >\n> {\n  return () => _createTable(undefined, undefined, opts)\n}\n\nexport type TableFactory<TGenerics extends Partial<DefaultGenerics>> = {\n  __options: CreateTableFactoryOptions<any, any, any>\n  createColumns: (columns: ColumnDef<TGenerics>[]) => ColumnDef<TGenerics>[]\n  createGroup: (\n    column: Overwrite<\n      | Overwrite<\n          _NonGenerated<ColumnDef<TGenerics>>,\n          {\n            header: string\n            id?: string\n          }\n        >\n      | Overwrite<\n          _NonGenerated<ColumnDef<TGenerics>>,\n          {\n            id: string\n            header?: string | ColumnDef<TGenerics>['header']\n          }\n        >,\n      { accessorFn?: never; accessorKey?: never }\n    >\n  ) => ColumnDef<TGenerics>\n  createDisplayColumn: (\n    column: PartialKeys<\n      _NonGenerated<ColumnDef<TGenerics>>,\n      'accessorFn' | 'accessorKey'\n    >\n  ) => ColumnDef<TGenerics>\n  createDataColumn: <\n    TAccessor extends AccessorFn<TGenerics['Row']> | keyof TGenerics['Row']\n  >(\n    accessor: TAccessor,\n    column: Overwrite<\n      TAccessor extends (...args: any[]) => any\n        ? // Accessor Fn\n          _NonGenerated<ColumnDef<TGenerics>>\n        : TAccessor extends keyof TGenerics['Row']\n        ? // Accessor Key\n          Overwrite<\n            _NonGenerated<ColumnDef<TGenerics>>,\n            {\n              id?: string\n            }\n          >\n        : never,\n      {\n        accessorFn?: never\n        accessorKey?: never\n      }\n    >\n  ) => ColumnDef<TGenerics>\n}\n\nexport function createTable<TRow>() {\n  return _createTable<Overwrite<PartialGenerics, { Row: TRow }>>()\n}\n\nfunction _createTable<TGenerics extends PartialGenerics>(\n  _?: undefined,\n  __?: undefined,\n  __options?: CreateTableFactoryOptions<any, any, any>\n): TableFactory<TGenerics> {\n  return {\n    __options: __options || {},\n    createColumns: columns => columns,\n    createDisplayColumn: column => column as any,\n    createGroup: column => column as any,\n    createDataColumn: (accessor, column): any => {\n      column = {\n        ...column,\n        id: column.id,\n      }\n\n      if (typeof accessor === 'string') {\n        return {\n          ...column,\n          id: column.id ?? accessor,\n          accessorKey: accessor,\n        }\n      }\n\n      if (typeof accessor === 'function') {\n        return {\n          ...column,\n          accessorFn: accessor,\n        }\n      }\n\n      throw new Error('Invalid accessor')\n    },\n  }\n}\n", "import { PartialGenerics, TableInstance, Row, RowModel } from '../types'\n\nexport function columnFilterRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const columnFilters = instance.getState().columnFilters\n\n  const newFilteredFlatRows: Row<TGenerics>[] = []\n  const newFilteredRowsById: Record<string, Row<TGenerics>> = {}\n\n  const filterFromChildrenUp = instance.options.filterFromChildrenUp\n\n  const filterRows = (rowsToFilter: Row<TGenerics>[], depth: number) => {\n    columnFilters.forEach(({ id: columnId, value: filterValue }) => {\n      // Find the columnFilters column\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `React-Table: Could not find a column with id: ${columnId}`\n          )\n        }\n        throw new Error()\n      }\n\n      if (depth === 0) {\n        const preFilteredRows = [...rowsToFilter]\n        column.getPreFilteredRows = () => preFilteredRows\n      }\n\n      const filterFn = instance.getColumnFilterFn(column.id)\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Could not find a valid 'column.filterType' for column with the ID: ${column.id}.`\n          )\n        }\n        return\n      }\n\n      // Pass the rows, id, filterValue and column to the filterFn\n      // to get the filtered rows back\n      rowsToFilter = filterFn(rowsToFilter, [columnId], filterValue)\n    })\n\n    return rowsToFilter\n  }\n\n  if (filterFromChildrenUp) {\n    const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n      // Filter from children up\n      rowsToFilter = rowsToFilter.filter(row => {\n        if (!row.subRows?.length) {\n          return true\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n\n        return row.subRows.length\n      })\n\n      rowsToFilter = filterRows(rowsToFilter, depth)\n\n      // Apply the filter to any subRows\n      rowsToFilter.forEach(row => {\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      })\n\n      return rowsToFilter\n    }\n\n    return {\n      rows: recurseFilterRows(rowModel.rows),\n      flatRows: newFilteredFlatRows,\n      rowsById: newFilteredRowsById,\n    }\n  }\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n    // Filter from parents downward\n    rowsToFilter = filterRows(rowsToFilter, depth)\n\n    // Apply the filter to any subRows\n    // We technically could do this recursively in the above loop,\n    // but that would severely hinder the API for the user, since they\n    // would be required to do that recursion in some scenarios\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!filterFromChildrenUp) {\n        if (!row.subRows?.length) {\n          return\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n      }\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowModel.rows),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n", "import { PartialGenerics, TableInstance, Row, RowModel } from '../types'\n\nexport function globalFilterRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const globalFilter = instance.getState().globalFilter\n  const newFilteredFlatRows: Row<TGenerics>[] = []\n  const newFilteredRowsById: Record<string, Row<TGenerics>> = {}\n\n  const filterFromChildrenUp = instance.options.filterFromChildrenUp\n\n  const filterFn = instance.getGlobalFilterFn()\n\n  if (!filterFn) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Could not find a valid 'globalFilterType'`)\n    }\n    return rowModel\n  }\n\n  const filterableColumns = instance\n    .getAllLeafColumns()\n    .filter(column => column.getCanGlobalFilter())\n\n  const filterableColumnIds = filterableColumns.map(d => d.id)\n\n  if (filterFromChildrenUp) {\n    const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n      // Filter from children up\n      rowsToFilter = rowsToFilter.filter(row => {\n        if (!row.subRows?.length) {\n          return true\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n\n        return row.subRows.length\n      })\n\n      rowsToFilter = filterFn(rowsToFilter, filterableColumnIds, globalFilter)\n\n      // Apply the filter to any subRows\n      rowsToFilter.forEach(row => {\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      })\n\n      return rowsToFilter\n    }\n\n    return {\n      rows: recurseFilterRows(rowModel.rows),\n      flatRows: newFilteredFlatRows,\n      rowsById: newFilteredRowsById,\n    }\n  }\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n    // Filter from parents downward\n    rowsToFilter = filterFn(rowsToFilter, filterableColumnIds, globalFilter)\n\n    // Apply the filter to any subRows\n    // We technically could do this recursively in the above loop,\n    // but that would severely hinder the API for the user, since they\n    // would be required to do that recursion in some scenarios\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!filterFromChildrenUp) {\n        if (!row.subRows?.length) {\n          return\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n      }\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowModel.rows),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n", "import { PartialGenerics, TableInstance, Row, RowModel } from '../types'\nimport { SortingFn } from '../features/Sorting'\n\nexport function sortRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const sortingState = instance.getState().sorting\n\n  const sortedFlatRows: Row<TGenerics>[] = []\n\n  // Filter out sortings that correspond to non existing columns\n  const availableSorting = sortingState.filter(sort =>\n    instance.getColumnCanSort(sort.id)\n  )\n\n  const columnInfoById: Record<\n    string,\n    {\n      sortUndefined?: false | -1 | 1\n      invertSorting?: boolean\n      sortingFn: SortingFn<TGenerics>\n    }\n  > = {}\n\n  availableSorting.forEach(sortEntry => {\n    const column = instance.getColumn(sortEntry.id)!\n\n    columnInfoById[sortEntry.id] = {\n      sortUndefined: column.sortUndefined,\n      invertSorting: column.invertSorting,\n      sortingFn: instance.getColumnSortingFn(sortEntry.id)!,\n    }\n  })\n\n  const sortData = (rows: Row<TGenerics>[]) => {\n    // This will also perform a stable sorting using the row index\n    // if needed.\n    const sortedData = rows.slice()\n\n    sortedData.sort((rowA, rowB) => {\n      for (let i = 0; i < availableSorting.length; i += 1) {\n        const sortEntry = availableSorting[i]!\n        const columnInfo = columnInfoById[sortEntry.id]!\n        const isDesc = sortEntry?.desc ?? false\n\n        if (columnInfo.sortUndefined) {\n          const aValue = rowA.values[sortEntry.id]\n          const bValue = rowB.values[sortEntry.id]\n\n          const aUndefined = typeof aValue === 'undefined'\n          const bUndefined = typeof bValue === 'undefined'\n\n          if (aUndefined || bUndefined) {\n            return aUndefined && bUndefined ? 0 : aUndefined ? 1 : -1\n          }\n        }\n\n        // This function should always return in ascending order\n        let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id)\n\n        if (sortInt !== 0) {\n          if (isDesc) {\n            sortInt *= -1\n          }\n\n          if (columnInfo.invertSorting) {\n            sortInt *= -1\n          }\n\n          return sortInt\n        }\n      }\n\n      return rowA.index - rowB.index\n    })\n\n    // If there are sub-rows, sort them\n    sortedData.forEach(row => {\n      sortedFlatRows.push(row)\n      if (!row.subRows || row.subRows.length <= 1) {\n        return\n      }\n      row.subRows = sortData(row.subRows)\n    })\n\n    return sortedData\n  }\n\n  return {\n    rows: sortData(rowModel.rows),\n    flatRows: sortedFlatRows,\n    rowsById: rowModel.rowsById,\n  }\n}\n", "import { PartialGenerics, TableInstance, Row, RowModel } from '../types'\nimport { flattenBy } from '../utils'\n\nexport function groupRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  sortedRowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const groupingState = instance.getState().grouping\n  // Filter the grouping list down to columns that exist\n  const existingGrouping = groupingState.filter(columnId =>\n    instance.getColumn(columnId)\n  )\n\n  // Find the columns that can or are aggregating\n  // Uses each column to aggregate rows into a single value\n  const aggregateRowsToValues = (\n    leafRows: Row<TGenerics>[],\n    groupedRows: Row<TGenerics>[],\n    depth: number\n  ) => {\n    const values: Record<string, unknown> = {}\n\n    instance.getAllLeafColumns().forEach(column => {\n      // Don't aggregate columns that are in the grouping\n      if (existingGrouping.includes(column.id)) {\n        values[column.id] = groupedRows[0]\n          ? groupedRows[0].values[column.id]\n          : null\n        return\n      }\n\n      // Aggregate the values\n      const aggregateFn = instance.getColumnAggregationFn(column.id)\n\n      if (aggregateFn) {\n        // Get the columnValues to aggregate\n        const groupedValues = groupedRows.map(row => row.values[column.id])\n\n        // Get the columnValues to aggregate\n        const leafValues = leafRows.map(row => {\n          let columnValue = row.values[column.id]\n\n          if (!depth && column.aggregateValue) {\n            columnValue = column.aggregateValue(columnValue)\n          }\n\n          return columnValue\n        })\n\n        values[column.id] = aggregateFn(leafValues, groupedValues)\n      } else if (column.aggregationType) {\n        console.info({ column })\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `React Table: Invalid column.aggregateType option for column listed above`\n            : ''\n        )\n      } else {\n        values[column.id] = null\n      }\n    })\n\n    return values\n  }\n\n  const groupedFlatRows: Row<TGenerics>[] = []\n  const groupedRowsById: Record<string, Row<TGenerics>> = {}\n  // const onlyGroupedFlatRows: Row[] = [];\n  // const onlyGroupedRowsById: Record<RowId, Row> = {};\n  // const nonGroupedFlatRows: Row[] = [];\n  // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n  // Recursively group the data\n  const groupUpRecursively = (\n    rows: Row<TGenerics>[],\n    depth = 0,\n    parentId: string\n  ) => {\n    // This is the last level, just return the rows\n    if (depth === existingGrouping.length) {\n      return rows\n    }\n\n    const columnId = existingGrouping[depth]!\n\n    // Group the rows together for this level\n    const rowGroupsMap = groupBy(rows, columnId)\n\n    // Peform aggregations for each group\n    const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n      ([groupingValue, groupedRows], index) => {\n        let id = `${columnId}:${groupingValue}`\n        id = parentId ? `${parentId}>${id}` : id\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth\n          ? flattenBy(groupedRows, row => row.leafRows)\n          : groupedRows\n\n        const values = aggregateRowsToValues(leafRows, groupedRows, depth)\n\n        const row = instance.createRow(id, undefined, index, depth, values)\n\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n        })\n\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return row\n      }\n    )\n\n    return aggregatedGroupedRows\n  }\n\n  const groupedRows = groupUpRecursively(sortedRowModel.rows, 0, '')\n\n  groupedRows.forEach(subRow => {\n    groupedFlatRows.push(subRow)\n    groupedRowsById[subRow.id] = subRow\n    // if (subRow.getIsGrouped?.()) {\n    //   onlyGroupedFlatRows.push(subRow);\n    //   onlyGroupedRowsById[subRow.id] = subRow;\n    // } else {\n    //   nonGroupedFlatRows.push(subRow);\n    //   nonGroupedRowsById[subRow.id] = subRow;\n    // }\n  })\n\n  return {\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n  }\n}\n\nfunction groupBy<TGenerics extends PartialGenerics>(\n  rows: Row<TGenerics>[],\n  columnId: string\n) {\n  const groupMap = new Map<any, Row<TGenerics>[]>()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.values[columnId]}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n", "import { PartialGenerics, TableInstance, Row, RowModel } from '../types'\n\nexport function expandRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  sortedRowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const expandedRows: Row<TGenerics>[] = []\n\n  const { expandSubRows } = instance.options\n\n  const handleRow = (row: Row<TGenerics>) => {\n    expandedRows.push(row)\n\n    if (\n      expandSubRows &&\n      row.subRows?.length &&\n      instance.getIsRowExpanded(row.id)\n    ) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  sortedRowModel.rows.forEach(handleRow)\n\n  return {\n    rows: expandedRows,\n    flatRows: sortedRowModel.flatRows,\n    rowsById: sortedRowModel.rowsById,\n  }\n}\n", "import { PartialGenerics, TableInstance, RowModel } from '../types'\nimport { expandRowsFn } from './expandRowsFn'\n\nexport function paginateRowsFn<TGenerics extends PartialGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const { pageSize, pageIndex } = instance.getState().pagination\n  let { rows, flatRows, rowsById } = rowModel\n  const pageStart = pageSize * pageIndex\n  const pageEnd = pageStart + pageSize\n\n  rows = rows.slice(pageStart, pageEnd)\n\n  if (!instance.options.paginateExpandedRows) {\n    return expandRowsFn(instance, {\n      rows,\n      flatRows,\n      rowsById,\n    })\n  }\n\n  return {\n    rows,\n    flatRows,\n    rowsById,\n  }\n}\n", "import * as React from 'react'\nexport * from '@tanstack/table-core'\n\nimport {\n  createTableInstance,\n  _NonGenerated,\n  PartialKeys,\n  Options,\n  TableInstance,\n  PartialGenerics,\n  CreateTableFactoryOptions,\n  TableFactory,\n} from '@tanstack/table-core'\n\nexport function useTable<TGenerics extends PartialGenerics>(\n  table: TableFactory<TGenerics>,\n  options: PartialKeys<\n    Omit<Options<TGenerics>, keyof CreateTableFactoryOptions<any, any, any>>,\n    'state' | 'onStateChange'\n  >\n): TableInstance<TGenerics> {\n  // Compose in the generic options to the user options\n  const resolvedOptions = {\n    ...(table.__options ?? {}),\n    state: {}, // Dummy state\n    onStateChange: () => {}, // noop\n    ...options,\n  }\n\n  // Create a new table instance and store it in state\n  const [instance] = React.useState(() =>\n    createTableInstance<TGenerics>(resolvedOptions)\n  )\n\n  // By default, manage table state here using the instance's initial state\n  const [state, setState] = React.useState(() => instance.initialState)\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  instance.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state,\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater)\n      options.onStateChange?.(updater)\n    },\n  }))\n\n  return instance\n}\n"],
  "mappings": "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",
  "names": []
}
