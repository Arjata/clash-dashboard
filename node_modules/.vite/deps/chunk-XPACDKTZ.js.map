{
  "version": 3,
  "sources": ["../../.pnpm/jotai@1.6.1_immer@9.0.12+react@18.0.0/node_modules/jotai/esm/index.js"],
  "sourcesContent": ["import { createContext, useState, useEffect, useRef, createElement, useDebugValue, useContext, useCallback, useReducer } from 'react';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a, _b;\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (promise) => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = { v: value, r: 0, d: /* @__PURE__ */ new Map() };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState) {\n          if (\"p\" in atomState) {\n            atomState.p.then(() => versionedAtomStateMap.delete(atom));\n          }\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(promiseOrValue.then((value) => {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n        flushPending(version);\n      }).catch((e) => {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(() => {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        flushPending(version);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = __spreadProps$1(__spreadValues$1({}, atomState), {\n        i: atomState.r\n      });\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.r !== atomState.i && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => writeGetter(a, options));\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        setAtomPromiseOrValue(version, a, v);\n        invalidateDependents(version, a);\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = void 0;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update);\n      const onUnmount = atom.onMount(setAtom);\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(void 0, atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        if (atomState !== committedAtomStateMap.get(atom)) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || \"v\" in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback) => {\n    const mounted = addAtom(atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState();\n  useEffect(() => {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = parentVersion ? { p: parentVersion } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && (typeof process !== \"object\" || process.env.NODE_ENV !== \"test\")) {\n    useDebugState(scopeContainerRef.current);\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nconst atomToPrintable = (atom) => atom.debugLabel || atom.toString();\nconst stateToPrintable = ([store, atoms]) => Object.fromEntries(atoms.flatMap((atom) => {\n  var _a, _b;\n  const mounted = (_a = store[DEV_GET_MOUNTED]) == null ? void 0 : _a.call(store, atom);\n  if (!mounted) {\n    return [];\n  }\n  const dependents = mounted.t;\n  const atomState = ((_b = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _b.call(store, atom)) || {};\n  return [\n    [\n      atomToPrintable(atom),\n      __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, \"e\" in atomState && { error: atomState.e }), \"p\" in atomState && { promise: atomState.p }), \"v\" in atomState && { value: atomState.v }), {\n        dependents: Array.from(dependents).map(atomToPrintable)\n      })\n    ]\n  ];\n}));\nconst useDebugState = (scopeContainer) => {\n  const { s: store } = scopeContainer;\n  const [atoms, setAtoms] = useState([]);\n  useEffect(() => {\n    var _a;\n    const callback = () => {\n      var _a2;\n      setAtoms(Array.from(((_a2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _a2.call(store)) || []));\n    };\n    const unsubscribe = (_a = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _a.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  useDebugValue([store, atoms], stateToPrintable);\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store } = useContext(ScopeContext);\n  const getAtomValue = useCallback((version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  }, [store, atom]);\n  const [[version, value, atomFromUseReducer], rerenderIfChanged] = useReducer(useCallback((prev, nextVersion) => {\n    const nextValue = getAtomValue(nextVersion);\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), void 0, () => {\n    const initialVersion = void 0;\n    const initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  });\n  if (atomFromUseReducer !== atom) {\n    rerenderIfChanged(void 0);\n  }\n  useEffect(() => {\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged);\n    rerenderIfChanged(void 0);\n    return unsubscribe;\n  }, [store, atom]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback((update) => {\n    if (!(\"write\" in atom) && typeof process === \"object\" && process.env.NODE_ENV !== \"production\") {\n      throw new Error(\"not writable atom\");\n    }\n    const write = (version) => store[WRITE_ATOM](atom, update, version);\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],
  "mappings": "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",
  "names": []
}
