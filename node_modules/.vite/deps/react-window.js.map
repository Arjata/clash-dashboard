{
  "version": 3,
  "sources": ["../../.pnpm/@babel+runtime@7.17.8/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js", "../../.pnpm/@babel+runtime@7.17.8/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js", "../../.pnpm/@babel+runtime@7.17.8/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js", "../../.pnpm/memoize-one@5.2.1/node_modules/memoize-one/dist/memoize-one.esm.js", "../../.pnpm/@babel+runtime@7.17.8/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/timer.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/domHelpers.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/createGridComponent.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/VariableSizeGrid.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/createListComponent.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/VariableSizeList.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/FixedSizeGrid.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/FixedSizeList.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/shallowDiffers.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/areEqual.js", "../../.pnpm/react-window@1.8.6_react-dom@18.0.0+react@18.0.0/node_modules/react-window/src/shouldComponentUpdate.js"],
  "sourcesContent": ["export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}", "import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}", "export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}", "var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n", "export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}", "// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n", "// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n", "// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n", "// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\ntype ItemType = 'column' | 'row';\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\ntype InstanceProps = {|\n  columnMetadataMap: ItemMetadataMap,\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  lastMeasuredColumnIndex: number,\n  lastMeasuredRowIndex: number,\n  rowMetadataMap: ItemMetadataMap,\n|};\n\nconst getEstimatedTotalHeight = (\n  { rowCount }: Props<any>,\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getEstimatedTotalWidth = (\n  { columnCount }: Props<any>,\n  {\n    columnMetadataMap,\n    estimatedColumnWidth,\n    lastMeasuredColumnIndex,\n  }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getItemMetadata = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = itemSize(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  let itemMetadataMap, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      itemType,\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      itemType,\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(\n      itemType,\n      props,\n      middle,\n      instanceProps\n    ).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    itemType,\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getOffsetForIndexAndAlignment = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: InstanceProps,\n  scrollbarSize: number\n): number => {\n  const size = itemType === 'column' ? props.width : props.height;\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\n\n  // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n  const estimatedTotalSize =\n    itemType === 'column'\n      ? getEstimatedTotalWidth(props, instanceProps)\n      : getEstimatedTotalHeight(props, instanceProps);\n\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\n  );\n  const minOffset = Math.max(\n    0,\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\n  );\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n    case 'end':\n      return minOffset;\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n  }\n};\n\nconst VariableSizeGrid = createGridComponent({\n  getColumnOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\n\n  getColumnStartIndexForOffset: (\n    props: Props<any>,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\n\n  getColumnStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { columnCount, width } = props;\n\n    const itemMetadata = getItemMetadata(\n      'column',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollLeft + width;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  getColumnWidth: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.columnMetadataMap[index].size,\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getOffsetForColumnAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'column',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getOffsetForRowAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'row',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getRowOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\n\n  getRowHeight: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.rowMetadataMap[index].size,\n\n  getRowStartIndexForOffset: (\n    props: Props<any>,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\n\n  getRowStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { rowCount, height } = props;\n\n    const itemMetadata = getItemMetadata(\n      'row',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollTop + height;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const {\n      estimatedColumnWidth,\n      estimatedRowHeight,\n    } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {},\n    };\n\n    instance.resetAfterColumnIndex = (\n      columnIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterRowIndex = (\n      rowIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterIndices = ({\n      columnIndex,\n      rowIndex,\n      shouldForceUpdate = true,\n    }: {\n      columnIndex?: number,\n      rowIndex?: number,\n      shouldForceUpdate: boolean,\n    }) => {\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(\n          instanceProps.lastMeasuredColumnIndex,\n          columnIndex - 1\n        );\n      }\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(\n          instanceProps.lastMeasuredRowIndex,\n          rowIndex - 1\n        );\n      }\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      } else if (typeof rowHeight !== 'function') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeGrid;\n", "// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n", "// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n", "// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst FixedSizeGrid = createGridComponent({\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\n    index * ((columnWidth: any): number),\n\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\n    ((columnWidth: any): number),\n\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\n    index * ((rowHeight: any): number),\n\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\n    ((rowHeight: any): number),\n\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\n    ((rowHeight: any): number) * rowCount,\n\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\n    ((columnWidth: any): number) * columnCount,\n\n  getOffsetForColumnAndAlignment: (\n    { columnCount, columnWidth, width }: Props<any>,\n    columnIndex: number,\n    align: ScrollToAlign,\n    scrollLeft: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastColumnOffset = Math.max(\n      0,\n      columnCount * ((columnWidth: any): number) - width\n    );\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * ((columnWidth: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      columnIndex * ((columnWidth: any): number) -\n        width +\n        scrollbarSize +\n        ((columnWidth: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getOffsetForRowAndAlignment: (\n    { rowHeight, height, rowCount }: Props<any>,\n    rowIndex: number,\n    align: ScrollToAlign,\n    scrollTop: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastRowOffset = Math.max(\n      0,\n      rowCount * ((rowHeight: any): number) - height\n    );\n    const maxOffset = Math.min(\n      lastRowOffset,\n      rowIndex * ((rowHeight: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      rowIndex * ((rowHeight: any): number) -\n        height +\n        scrollbarSize +\n        ((rowHeight: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: (\n    { columnWidth, columnCount }: Props<any>,\n    scrollLeft: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        Math.floor(scrollLeft / ((columnWidth: any): number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, columnCount, width }: Props<any>,\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * ((columnWidth: any): number);\n    const numVisibleColumns = Math.ceil(\n      (width + scrollLeft - left) / ((columnWidth: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, rowCount }: Props<any>,\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, rowCount, height }: Props<any>,\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * ((rowHeight: any): number);\n    const numVisibleRows = Math.ceil(\n      (height + scrollTop - top) / ((rowHeight: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        rowCount - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeGrid;\n", "// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst FixedSizeList = createListComponent({\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\n    index * ((itemSize: any): number),\n\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\n    ((itemSize: any): number),\n\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\n    ((itemSize: any): number) * itemCount,\n\n  getOffsetForIndexAndAlignment: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const lastItemOffset = Math.max(\n      0,\n      itemCount * ((itemSize: any): number) - size\n    );\n    const maxOffset = Math.min(\n      lastItemOffset,\n      index * ((itemSize: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      index * ((itemSize: any): number) - size + ((itemSize: any): number)\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center': {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      }\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    { itemCount, itemSize }: Props<any>,\n    offset: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\n    ),\n\n  getStopIndexForStartIndex: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    startIndex: number,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const offset = startIndex * ((itemSize: any): number);\n    const size = (((isHorizontal ? width : height): any): number);\n    const numVisibleItems = Math.ceil(\n      (size + scrollOffset - offset) / ((itemSize: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        itemCount - 1,\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeList;\n", "// @flow\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\n  for (let attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n  for (let attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n  return false;\n}\n", "// @flow\n\nimport shallowDiffers from './shallowDiffers';\n\n// Custom comparison function for React.memo().\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nexport default function areEqual(\n  prevProps: Object,\n  nextProps: Object\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\n  );\n}\n", "// @flow\n\nimport areEqual from './areEqual';\nimport shallowDiffers from './shallowDiffers';\n\n// Custom shouldComponentUpdate for class components.\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nexport default function shouldComponentUpdate(\n  nextProps: Object,\n  nextState: Object\n): boolean {\n  return (\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
